<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>마블배틀로얄</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        /* 기본 스타일 초기화 */
        body, h1, h2, p, button, textarea, label, h3, div, fieldset, legend {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Noto Sans KR', sans-serif;
        }

        body {
            background-color: #1a1a2e; 
            color: #e0e0e0; 
            display: flex;
            justify-content: center;
            align-items: flex-start; 
            min-height: 100vh;
            padding: 20px;
            overflow-y: auto; 
        }

        .container {
            background-color: #232334; 
            padding: 20px; 
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
            width: 100%;
            max-width: 900px; 
            text-align: center;
        }

        h1 {
            color: #f03a78; 
            margin-bottom: 20px;
            font-size: 2.2em; 
            font-weight: 700;
            letter-spacing: 1px;
        }

        h2 {
            color: #7aa5ff; 
            margin-bottom: 12px;
            font-size: 1.5em;
        }
        h3 {
            color: #9fa8da; 
            margin-top: 12px;
            margin-bottom: 6px;
            font-size: 1.05em;
            text-align: left;
        }

        /* 시작 화면 섹션 */
        #startScreen {
            background-color: #2a2a3e;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.2);
        }
        #gameDescription {
            background-color: #333343;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            text-align: left;
            font-size: 0.9em;
            line-height: 1.6;
            color: #d0d0ff;
        }
        #gameDescription h4 {
            color: #7aa5ff;
            margin-bottom: 8px;
            font-size: 1.1em;
        }
        #mapSelection, #perkSelection {
            margin-bottom: 15px;
        }
        #mapSelection h4, #perkSelection h4 {
            color: #c0c0ff;
            margin-bottom: 10px;
            font-size: 1em;
        }
        #mapSelection button, .perk-button {
            background-color: #4a4a5e;
            padding: 8px 15px;
            font-size: 0.9em;
            margin: 5px;
            border: 1px solid transparent; 
        }
        #mapSelection button.selected, .perk-button.selected {
            background-color: #7aa5ff;
            box-shadow: 0 0 10px rgba(122, 165, 255, 0.5);
            transform: translateY(-1px);
            border-color: #c0c0ff;
        }
        .perk-description {
            font-size: 0.8em;
            color: #aaa;
            display: block;
            margin-top: 3px;
        }


        .input-section label {
            display: block;
            margin-bottom: 8px;
            color: #c0c0ff;
            font-size: 0.95em;
            text-align: left;
        }

        #participantsInput {
            width: 100%;
            padding: 12px;
            border-radius: 8px;
            border: 1px solid #4a4a5e;
            background-color: #3a3a4e;
            color: #e0e0e0;
            font-size: 1em;
            min-height: 70px; 
            resize: vertical;
        }

        #participantsInput::placeholder {
            color: #888dac;
        }

        /* 버튼 스타일 */
        button {
            background-color: #f03a78;
            color: white;
            padding: 10px 18px; 
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.95em; 
            font-weight: 500;
            margin-top: 10px;
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
            box-shadow: 0 4px 8px rgba(240, 58, 120, 0.3);
        }
       
        button:hover {
            background-color: #d01a58;
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(240, 58, 120, 0.4);
        }

        button:disabled {
            background-color: #555;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }

        #resetButton {
            background-color: #7aa5ff;
            box-shadow: 0 4px 8px rgba(122, 165, 255, 0.3);
        }
        #resetButton:hover {
            background-color: #5c8ae6;
            box-shadow: 0 6px 12px rgba(122, 165, 255, 0.4);
        }

        /* 배속 버튼 그룹 */
        .speed-controls {
            margin-top: 8px;
            margin-bottom: 15px;
        }
        .speed-controls button {
            background-color: #4a4a5e;
            padding: 7px 13px;
            font-size: 0.85em;
            margin-left: 4px;
            margin-right: 4px;
        }
        .speed-controls button.active {
            background-color: #7aa5ff;
            box-shadow: 0 0 8px rgba(122, 165, 255, 0.5);
            transform: translateY(-1px); 
        }


        /* 아레나 섹션 */
        .arena-section {
            background-color: #2a2a3e;
            padding: 15px; 
            border-radius: 10px;
            margin-bottom: 20px;
            position: relative; 
            overflow: hidden; 
        }
        
        #gameCanvas {
            width: 100%;
            height: 450px; 
            border-radius: 8px;
            border: 1px solid #4a4a5e;
            margin-bottom: 10px;
            cursor: default; 
            transition: transform 0.5s ease-out; 
        }
        
        /* 플레이어 정보 및 배틀 로그 컨테이너 */
        #gameInfoContainer {
            display: flex;
            flex-direction: column; 
            gap: 15px;
        }

        #participantsDisplay {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 8px; 
            padding: 8px;
            background-color: #333343;
            border-radius: 8px;
            max-height: 150px; 
            overflow-y: auto;
        }

        .participant-card {
            background-color: #3a3a4e;
            color: #c0c0ff;
            border: 1px solid #5a5aff; 
            padding: 6px 10px; 
            border-radius: 6px;
            min-width: 85px; 
            text-align: center;
            font-size: 0.85em; 
            transition: all 0.3s ease-in-out;
            box-shadow: 0 0 6px rgba(90, 90, 255, 0.2);
        }
        .participant-card .job-display { 
            font-size: 0.75em;
            color: #aaa;
            margin-top: 2px;
        }
        
        .participant-card .hp-bar-container {
            width: 100%; height: 7px; background-color: #2c2c3a; 
            border-radius: 3px; margin-top: 4px; overflow: hidden;
            border: 1px solid #1e1e2d; 
        }
        .participant-card .hp-bar {
            height: 100%; width: 100%; background-color: #4caf50;
            border-radius: 3px; transition: width 0.2s ease;
        }
         .participant-card.low-hp .hp-bar { background-color: #f44336; }
        .participant-card.eliminated {
            opacity: 0.4; background-color: #444; border-color: #666;
            transform: scale(0.95); box-shadow: none;
        }
        .participant-card.eliminated .hp-bar { width: 0% !important; }
        .participant-card.winner {
            background-color: #ffd700; color: #333; border-color: #ffc107;
            transform: scale(1.05); font-weight: 700; animation: pulseCard 1.5s infinite;
        }

        @keyframes pulseCard {
            0% { transform: scale(1.03); box-shadow: 0 0 12px rgba(255, 215, 0, 0.4);}
            50% { transform: scale(1.08); box-shadow: 0 0 20px rgba(255, 215, 0, 0.6);}
            100% { transform: scale(1.03); box-shadow: 0 0 12px rgba(255, 215, 0, 0.4);}
        }

        /* 배틀 로그 */
        #battleLogContainer{
            padding: 8px;
            background-color: #333343;
            border-radius: 8px;
            flex-grow: 1; 
        }
        #battleLog {
            font-size: 0.9em; 
            color: #ffc107; 
            min-height: 35px; 
            font-weight: 500;
            text-align: left;
            max-height: 130px; 
            overflow-y: auto;
            padding: 6px;
            background-color: #2c2c3a; 
            border-radius: 5px;
        }
      
        #battleLog p {
             animation: fadeInLog 0.3s ease;
             margin-bottom: 3px; 
        }
        .log-stats { color: #66bfff; font-style: italic; }
        .log-event { color: #ffeb3b; }
        .log-item { color: #90ee90; }
        .log-ultimate { color: #ff69b4; font-weight: bold; }
        .log-pit, .log-terrain { color: #a8836b;}


        @keyframes fadeInLog {
            from { opacity: 0; transform: translateX(-10px); }
            to { opacity: 1; transform: translateX(0); }
        }

        /* 우승자 및 게임 결과 분석 섹션 */
        .winner-section, #gameResultAnalysisSection {
            background-color: #2a2a3e; padding: 20px; border-radius: 10px;
            margin-top: 20px; border: 2px solid #f03a78;
            box-shadow: 0 0 18px rgba(240, 58, 120, 0.3);
        }
        #winnerName {
            font-size: 2.3em; color: #f03a78; font-weight: 700;
            margin-bottom: 8px; animation: winnerPop 0.5s ease-out;
        }
       
        #gameStatsDisplay, #detailedPlayerStats { 
            margin-top: 15px; padding: 12px;
            background-color: #333343; border-radius: 8px;
            text-align: left; font-size: 0.85em;
        }
        #gameStatsDisplay h4, #detailedPlayerStats h4, #sortCriteriaSelection h4 {
            color: #7aa5ff; margin-bottom: 8px;
        }
        #gameStatsDisplay p, #detailedPlayerStats p {
            margin-bottom: 4px; color: #e0e0e0;
        }
        .player-stat-entry {
            padding: 8px 0;
            border-bottom: 1px solid #4a4a5e;
        }
        .player-stat-entry:last-child {
            border-bottom: none;
        }
        .player-stat-entry strong {
            color: #f0a0a0; 
        }
        .player-rank {
            font-weight: bold;
            color: #ffd700; 
            margin-right: 5px;
        }
        #sortCriteriaSelection {
            margin-bottom: 10px;
        }
        #sortCriteriaSelection button {
            background-color: #4a4a5e;
            padding: 6px 12px;
            font-size: 0.85em;
            margin: 0 5px;
        }
        #sortCriteriaSelection button.selected {
            background-color: #7aa5ff;
            box-shadow: 0 0 8px rgba(122, 165, 255, 0.4);
        }
        
        @keyframes winnerPop {
            0% { transform: scale(0.5); opacity: 0;}
            80% { transform: scale(1.1); opacity: 1;}
            100% { transform: scale(1); opacity: 1;}
        }

        /* 커스텀 알림창 */
        #customAlertModal {
            position: fixed; left: 50%; top: 50%; transform: translate(-50%, -50%);
            background-color: #3a3a4e; color: white; padding: 20px;
            border: 1px solid #f03a78; border-radius: 10px; z-index: 1000;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5); width: 90%; max-width: 320px;
            text-align: center;
        }
        #customAlertModal p { margin: 0 0 12px 0; font-size: 1em; line-height: 1.5; }
        #customAlertModal button { background-color: #f03a78; padding: 8px 18px; }
        #customAlertModal button:hover { background-color: #d01a58; }

        /* 모바일 반응형 */
        @media (max-width: 768px) { 
            .container { padding: 15px; }
            h1 { font-size: 2em; }
            #gameCanvas { height: 400px; }
            #gameInfoContainer { flex-direction: column; } 
            #participantsDisplay { max-height: 120px; }
            #battleLog { max-height: 100px; }
        }

        @media (max-width: 480px) { 
            body { padding: 10px; }
            .container { padding: 10px;}
            h1 { font-size: 1.7em; margin-bottom: 15px; }
            h2 { font-size: 1.3em; }
            h3 { font-size: 0.95em; }
            #gameDescription { padding: 10px; font-size: 0.85em; }
            #mapSelection button, .perk-button, #sortCriteriaSelection button { padding: 7px 12px; font-size: 0.85em; margin:3px; }
            #participantsInput { min-height: 60px; padding: 10px; }
            button { padding: 9px 16px; font-size: 0.9em;}
            .participant-card { padding: 5px 8px; font-size: 0.8em; min-width: 75px;}
            #winnerName { font-size: 1.8em; }
            #gameCanvas { height: 300px; } 
            #battleLog { max-height: 80px; font-size: 0.85em;}
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>마블배틀로얄</h1>

        <div id="startScreen">
            <div id="gameDescription">
                <h4>🚀 마블 배틀로얄에 오신 것을 환영합니다! 🚀</h4>
                <p>최후의 1인이 될 때까지 아레나에서 격돌하세요! 각 캐릭터는 고유한 직업과 궁극기를 가지고 있습니다. 맵 곳곳에 있는 아이템을 활용하여 전투를 유리하게 이끌어보세요. 시작 전 특성을 선택하여 전략을 더할 수도 있습니다! 행운을 빕니다!</p>
            </div>
            <div id="mapSelection">
                <h4>🗺️ 맵 선택 🗺️</h4>
                <button class="map-button" data-map="default">기본</button>
                <button class="map-button" data-map="forest">숲</button>
                <button class="map-button" data-map="lava">용암</button>
                <button class="map-button selected" data-map="random">무작위</button>
            </div>
            <div id="perkSelection">
                <h4>✨ 특성 선택 ✨</h4>
                <button class="perk-button selected" data-perk="none">선택 안함</button>
                <button class="perk-button" data-perk="toughness">강인함 <span class="perk-description">(최대 체력 +15)</span></button>
                <button class="perk-button" data-perk="swiftness">신속함 <span class="perk-description">(이동 속도 +10%)</span></button>
                <button class="perk-button" data-perk="luck">행운 <span class="perk-description">(시작 아이템 1개)</span></button>
            </div>
            <div class="input-section">
                <label for="participantsInput">참가자 명단 (예: 아이언맨, 캡틴*3, 토르):</label>
                <textarea id="participantsInput" rows="3" placeholder="아이언맨, 캡틴 아메리카*2, 토르, 헐크"></textarea>
                <button id="startButton">배틀 시작!</button>
            </div>
        </div>
        
        <div id="gameScreen" style="display:none;">
            <div class="speed-controls">
                <h3>게임 속도:</h3>
                <button id="speed1x" class="active">1x</button>
                <button id="speed1_5x">1.5x</button> 
                <button id="speed2x">2x</button>
            </div>

            <div id="arena" class="arena-section">
                <h2>배틀 아레나</h2>
                <canvas id="gameCanvas"></canvas>
            </div>
            <div id="gameInfoContainer">
                <div id="participantsDisplay"></div>
                <div id="battleLogContainer">
                    <h3>실시간 배틀 로그:</h3>
                    <div id="battleLog"></div>
                </div>
            </div>
        </div>


        <div id="winnerSection" class="winner-section" style="display:none;">
            <h2>최종 우승자!</h2>
            <p id="winnerName"></p>
            <div id="gameStatsDisplay"></div> 
            <button id="resetButton">다시 하기</button>
        </div>
        <div id="gameResultAnalysisSection" style="display:none;">
            <h2>게임 결과 분석</h2>
            <div id="sortCriteriaSelection">
                <h4>정렬 기준:</h4>
                <button class="sort-button selected" data-sort="survivalTime">생존 시간</button>
                <button class="sort-button" data-sort="damageDealt">가한 데미지</button>
                <button class="sort-button" data-sort="kills">킬 수</button>
            </div>
            <div id="detailedPlayerStats"></div>
             <button id="resetButtonFromAnalysis">처음으로</button>
        </div>
    </div>

    <script>
        // DOM 요소
        const startScreenEl = document.getElementById('startScreen');
        const gameScreenEl = document.getElementById('gameScreen');
        const mapSelectionButtons = document.querySelectorAll('.map-button');
        const perkSelectionButtons = document.querySelectorAll('.perk-button');
        const sortCriteriaButtons = document.querySelectorAll('.sort-button'); 
        const participantsInputEl = document.getElementById('participantsInput');
        const startButtonEl = document.getElementById('startButton');
        const participantsDisplayEl = document.getElementById('participantsDisplay');
        const battleLogEl = document.getElementById('battleLog');
        const winnerSectionEl = document.getElementById('winnerSection');
        const winnerNameEl = document.getElementById('winnerName');
        const resetButtonEl = document.getElementById('resetButton');
        const gameResultAnalysisSectionEl = document.getElementById('gameResultAnalysisSection');
        const detailedPlayerStatsEl = document.getElementById('detailedPlayerStats');
        const resetButtonFromAnalysisEl = document.getElementById('resetButtonFromAnalysis');
        const arenaSectionEl = document.getElementById('arena');
        const gameCanvasEl = document.getElementById('gameCanvas');
        const ctx = gameCanvasEl.getContext('2d');
        const gameStatsDisplayEl = document.getElementById('gameStatsDisplay');
        const speedControlsEl = document.querySelector('.speed-controls');
        const speed1xButton = document.getElementById('speed1x');
        const speed1_5xButton = document.getElementById('speed1_5x'); 
        const speed2xButton = document.getElementById('speed2x');


        // 게임 상태 변수
        let allPlayers = [];
        let items = [];
        let obstacles = [];
        let particles = []; 
        let attackEffects = []; 
        let gameLoopId;
        let gameOver = false;
        let uniqueIdCounter = 0; 
        let battleStatsLogInterval = 0; 
        let gameStartTime = 0; 
        let gameSpeedMultiplier = 1; 
        let isClutchCamActive = false; 
        let lastFrameTime = 0; 
        let baseNameColors = {}; 
        let currentMapTheme = 'random'; 
        let selectedMapTheme = 'random'; 
        let selectedPerk = 'none'; 
        let selectedSortCriterion = 'survivalTime'; 

        const PLAYER_RADIUS_BASE = 8; 
        let PLAYER_RADIUS = PLAYER_RADIUS_BASE + 4; // 플레이어 크기 증가 (12px)

        const PLAYER_HP_BASE = 100; 
        let PLAYER_HP = PLAYER_HP_BASE; 
        const PLAYER_SPEED_BASE_VAL = 1.2; 
        let PLAYER_SPEED_BASE = PLAYER_SPEED_BASE_VAL; 

        const ATTACK_POWER_BASE = 3; 
        const ATTACK_RANGE_MELEE = PLAYER_RADIUS * 3.5; 
        const ATTACK_RANGE_RANGED = PLAYER_RADIUS * 15; 
        const ATTACK_COOLDOWN_BASE = 35; 
        const ATTACK_EFFECT_DURATION = 8; 
        const EVADE_DURATION_BASE = 20; 
        const ITEM_EFFECT_DURATION_BASE = 300; 
        const ULTIMATE_CHARGE_MAX = 100; 
        const ULTIMATE_CHARGE_PER_HIT = 5; 
        const ULTIMATE_CHARGE_PER_KILL = 20; 
        const ULTIMATE_DURATION_BASE = 180; 
        const ULTIMATE_COOLDOWN_BASE = 600; 
        
        const ITEM_RADIUS = 6; 
        const OBSTACLE_MIN_SIZE = 30;
        const OBSTACLE_MAX_SIZE = 70; // 직사각형 장애물을 위해 최대 크기 약간 늘림
        const OBSTACLE_MAX_LENGTH_FACTOR = 2.0; // 직사각형 장애물의 최대 길이 비율 (정사각형 대비)
        const NUM_OBSTACLES_BASE = 4; 
        const NUM_PITS_BASE = 2; 
        const NUM_SPECIAL_TERRAIN_BASE = 3; 
        const NUM_ITEMS_MAX = 4; 
        const ITEM_SPAWN_INTERVAL_BASE = 60 * 8; 
        let itemSpawnTimer = 0;
        const PIT_DAMAGE = 0.2; 
        const PIT_SLOW_FACTOR = 0.6; 
        const SWAMP_SLOW_FACTOR = 0.5;
        const SPEED_PAD_BOOST_FACTOR = 1.8;
        const SPEED_PAD_DURATION = 120; 

        const GRID_CELL_SIZE = PLAYER_RADIUS * 2.5; 
        let grid = [];
        const PATHFINDING_COOLDOWN_BASE = 25; 
        const PLAYER_CLASSES = { 
            'Brawler': '돌격자',
            'Berserker': '버서커',
            'Archer': '궁수',
            'Mage': '마법사'
        };
        const PLAYER_CLASS_KEYS = Object.keys(PLAYER_CLASSES); 

        const PREDEFINED_COLORS = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#FED766', '#2AB7CA', '#F0C419', '#A2D4AB', '#F8A5C2', '#8785A2', '#FFD166', '#06D6A0', '#118AB2', '#EF476F', '#FF9F1C', '#540D6E'];
        let colorIndex = 0;

        const NAME_OFFSET_Y = PLAYER_RADIUS + 10; // 이름 Y축 위치 조정 (플레이어 크기 및 원형 궁극기 게이지 고려)
        const HP_BAR_OFFSET_Y = PLAYER_RADIUS + 2;  // HP 바 Y축 위치 조정 (플레이어 원 바로 위, 궁극기 게이지 안쪽)


        // --- A* 경로 탐색 알고리즘 (이전과 동일) ---
        class Node {
            constructor(x, y, parent = null) {
                this.x = x; this.y = y; this.parent = parent;
                this.g = 0; this.h = 0; this.f = 0; 
            }
            equals(otherNode) { return this.x === otherNode.x && this.y === otherNode.y; }
        }
        function heuristic(nodeA, nodeB) { return Math.abs(nodeA.x - nodeB.x) + Math.abs(nodeA.y - nodeB.y); }
        function aStar(startX, startY, endX, endY, worldGrid) {
            const openList = []; const closedList = [];
            const startNode = new Node(startX, startY); const endNode = new Node(endX, endY);
            openList.push(startNode);
            while (openList.length > 0) {
                let lowestFIndex = 0;
                for (let i = 1; i < openList.length; i++) {
                    if (openList[i].f < openList[lowestFIndex].f) lowestFIndex = i;
                }
                const currentNode = openList[lowestFIndex];
                if (currentNode.equals(endNode)) {
                    const path = []; let temp = currentNode;
                    while (temp) { path.push({x: temp.x, y: temp.y}); temp = temp.parent; }
                    return path.reverse(); 
                }
                openList.splice(lowestFIndex, 1); closedList.push(currentNode);
                const directions = [[0, -1], [0, 1], [-1, 0], [1, 0], [-1, -1], [-1, 1], [1, -1], [1, 1]];
                for (const dir of directions) {
                    const nodeX = currentNode.x + dir[0]; const nodeY = currentNode.y + dir[1];
                    if (!worldGrid || worldGrid.length === 0 || !worldGrid[0] ||
                        nodeX < 0 || nodeX >= worldGrid[0].length || 
                        nodeY < 0 || nodeY >= worldGrid.length || 
                        worldGrid[nodeY][nodeX] === 1) continue; 
                    
                    if (Math.abs(dir[0]) === 1 && Math.abs(dir[1]) === 1) {
                        if (worldGrid[currentNode.y] && worldGrid[currentNode.y][nodeX] === 1 || 
                            worldGrid[nodeY] && worldGrid[nodeY][currentNode.x] === 1) {
                            continue;
                        }
                    }

                    const neighborNode = new Node(nodeX, nodeY, currentNode);
                    if (closedList.some(node => node.equals(neighborNode))) continue;
                    
                    const gScore = currentNode.g + ((dir[0] === 0 || dir[1] === 0) ? 1 : 1.414); 

                    if (!openList.some(node => node.equals(neighborNode) && gScore >= node.g)) {
                        neighborNode.g = gScore;
                        neighborNode.h = heuristic(neighborNode, endNode);
                        neighborNode.f = neighborNode.g + neighborNode.h;
                        openList.push(neighborNode);
                    }
                }
            }
            return []; 
        }
        // --- A* 경로 탐색 알고리즘 끝 ---

        // 파티클 클래스 (이전과 동일)
        class Particle {
            constructor(x, y, color, size = Math.random() * 2 + 1, life = 20 + Math.random() * 20, vx = (Math.random() - 0.5) * 4, vy = (Math.random() - 0.5) * 4) {
                this.x = x; this.y = y; this.radius = size;
                this.color = color; this.life = life; 
                this.vx = vx; 
                this.vy = vy;
                this.opacity = 1;
            }
            update(deltaTime) { 
                this.x += this.vx * deltaTime; 
                this.y += this.vy * deltaTime; 
                this.life -= 1 * deltaTime; 
                this.opacity = Math.max(0, this.life / (20 + Math.random() * 20)); 
            }
            draw() {
                ctx.save(); ctx.globalAlpha = this.opacity;
                ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color; ctx.fill(); ctx.restore();
            }
        }
        
        // 공격 효과 클래스 (반지름 오류 수정)
        class AttackEffect {
            constructor(startX, startY, endX, endY, color, lineWidth = 1, shadowBlur = 5, type = 'line', customData = {}) {
                this.startX = startX; this.startY = startY;
                this.endX = endX; this.endY = endY;
                this.color = color; this.duration = (customData.duration || ATTACK_EFFECT_DURATION) / gameSpeedMultiplier; 
                this.currentFrame = 0;
                this.lineWidthBase = lineWidth;
                this.shadowBlurBase = shadowBlur;
                this.type = type; 
                this.customData = customData;

                if (type === 'projectile') {
                    this.px = startX; this.py = startY;
                    const angle = Math.atan2(endY - startY, endX - startX);
                    this.pvx = Math.cos(angle) * (customData.speed || 15); 
                    this.pvy = Math.sin(angle) * (customData.speed || 15);
                    this.duration = Math.hypot(endX-startX, endY-startY) / (customData.speed || 15) / gameSpeedMultiplier; 
                } else if (type === 'slash') {
                    this.angle = Math.atan2(endY - startY, endX - startX);
                    this.radius = customData.radius || PLAYER_RADIUS * 2;
                } else if (type === 'aura') {
                    this.radius = 0;
                    this.maxRadius = customData.maxRadius || PLAYER_RADIUS * 3;
                    this.opacity = customData.opacity || 0.7;
                } else if (type === 'magic_bolt') {
                    this.px = startX; this.py = startY;
                    const angle = Math.atan2(endY - startY, endX - startX);
                    this.pvx = Math.cos(angle) * 12; 
                    this.pvy = Math.sin(angle) * 12;
                    this.trail = [];
                    this.duration = Math.hypot(endX-startX, endY-startY) / 12 / gameSpeedMultiplier;
                }
            }
            update(deltaTime) { 
                this.currentFrame += 1 * deltaTime; 
                if (this.type === 'projectile' || this.type === 'magic_bolt') {
                    this.px += this.pvx * deltaTime;
                    this.py += this.pvy * deltaTime;
                    if (this.type === 'magic_bolt') {
                        this.trail.push({x: this.px, y: this.py, opacity: 1});
                        if (this.trail.length > 10) this.trail.shift();
                        this.trail.forEach(p => p.opacity -= 0.1 * deltaTime);
                    }
                } else if (this.type === 'aura') {
                    this.radius = (this.currentFrame / this.duration) * this.maxRadius;
                    this.opacity = Math.max(0, (this.customData.opacity || 0.7) * (1 - this.currentFrame / this.duration));
                }
            }
            draw() {
                const progress = this.currentFrame / this.duration;
                if (progress > 1 && this.type !== 'wave' && this.type !== 'static_aoe' && this.type !== 'aura') return; 
                ctx.save();
                if (this.type === 'line') {
                    ctx.beginPath();
                    ctx.moveTo(this.startX, this.startY);
                    const dx = this.endX - this.startX;
                    const dy = this.endY - this.startY;
                    const length = Math.hypot(dx, dy);
                    const overshootFactor = 1.1; 
                    ctx.lineTo(this.startX + dx / length * (length * overshootFactor), this.startY + dy / length * (length * overshootFactor));
                    ctx.strokeStyle = this.color;
                    ctx.lineWidth = this.lineWidthBase + (1-progress) * (this.lineWidthBase * 1.5); 
                    ctx.shadowColor = this.color; 
                    ctx.shadowBlur = this.shadowBlurBase + (1-progress) * this.shadowBlurBase;
                    ctx.globalAlpha = 0.6 + (1 - progress) * 0.4; 
                    ctx.stroke();
                } else if (this.type === 'projectile') {
                    ctx.beginPath();
                    let projectileRadius = PLAYER_RADIUS / (this.customData.sizeFactor || 2);
                    projectileRadius = Math.max(0.1, projectileRadius); // 반지름 음수 방지
                    ctx.arc(this.px, this.py, projectileRadius , 0, Math.PI * 2);
                    ctx.fillStyle = this.color;
                    ctx.shadowColor = this.color; 
                    ctx.shadowBlur = this.customData.shadow || 8;
                    ctx.fill();
                    if (this.customData.trail) { 
                        const trailLength = 5;
                        const baseTrailRadius = PLAYER_RADIUS / (this.customData.sizeFactor || 2);
                        for(let i=0; i < trailLength; i++) {
                            ctx.globalAlpha = 0.5 * (1 - i/trailLength);
                            ctx.beginPath();
                            let currentTrailRadius = baseTrailRadius * (1 - i/trailLength);
                            currentTrailRadius = Math.max(0.1, currentTrailRadius); // 반지름 음수 방지
                            ctx.arc(this.px - this.pvx * i * 0.2, this.py - this.pvy * i * 0.2, currentTrailRadius, 0, Math.PI * 2);
                            ctx.fillStyle = this.color;
                            ctx.fill();
                        }
                        ctx.globalAlpha = 1;
                    }
                } else if (this.type === 'slash') {
                    ctx.beginPath();
                    const startAngle = this.angle - Math.PI / 6;
                    const endAngle = this.angle + Math.PI / 6;
                    ctx.arc(this.startX, this.startY, this.radius * progress, startAngle, endAngle);
                    ctx.strokeStyle = this.color;
                    ctx.lineWidth = this.lineWidthBase * (1 - progress * 0.5);
                    ctx.globalAlpha = 0.8 * (1 - progress);
                    ctx.stroke();
                } else if (this.type === 'aura') {
                    if (this.currentFrame >= this.duration) return;
                    ctx.beginPath();
                    ctx.arc(this.startX, this.startY, this.radius, 0, Math.PI * 2);
                    ctx.fillStyle = this.color;
                    ctx.globalAlpha = this.opacity;
                    ctx.fill();
                } else if (this.type === 'magic_bolt') {
                    this.trail.forEach((p, index) => {
                        ctx.beginPath();
                        let trailParticleRadius = PLAYER_RADIUS / 2.5 * p.opacity;
                        trailParticleRadius = Math.max(0.1, trailParticleRadius); // 반지름 음수 방지
                        ctx.arc(p.x, p.y, trailParticleRadius, 0, Math.PI * 2);
                        ctx.fillStyle = this.color;
                        ctx.globalAlpha = p.opacity * 0.7;
                        ctx.fill();
                    });
                    ctx.globalAlpha = 1;
                    ctx.beginPath();
                    let magicBoltRadius = PLAYER_RADIUS / 2;
                    magicBoltRadius = Math.max(0.1, magicBoltRadius); // 반지름 음수 방지
                    ctx.arc(this.px, this.py, magicBoltRadius, 0, Math.PI * 2);
                    ctx.fillStyle = this.color;
                    ctx.shadowColor = this.color; 
                    ctx.shadowBlur = 10;
                    ctx.fill();
                }
                ctx.restore();
            }
        }


        // 플레이어 클래스 (특성 적용, AI 개선, 원형 궁극기 게이지)
        class Player {
            constructor(name, baseId, playerColor, perk = 'none') { 
                this.baseName = name.split('_')[0]; 
                this.name = name; 
                this.id = `${baseId}-${uniqueIdCounter++}`;
                this.x = Math.random() * (gameCanvasEl.width - PLAYER_RADIUS * 2) + PLAYER_RADIUS;
                this.y = Math.random() * (gameCanvasEl.height - PLAYER_RADIUS * 2) + PLAYER_RADIUS;
                this.radius = PLAYER_RADIUS; 
                const classKey = PLAYER_CLASS_KEYS[uniqueIdCounter % PLAYER_CLASS_KEYS.length];
                this.job = PLAYER_CLASSES[classKey]; 
                this.color = playerColor; 
                this.originalColor = this.color; 
                
                this.perk = perk;
                this.hp = PLAYER_HP_BASE;
                this.maxHp = PLAYER_HP_BASE;
                this.speed = PLAYER_SPEED_BASE_VAL;
                this.isHiding = false; 

                if (this.perk === 'toughness') {
                    this.hp += 15;
                    this.maxHp += 15;
                } else if (this.perk === 'swiftness') {
                    this.speed *= 1.10;
                }
                
                this.attackPower = ATTACK_POWER_BASE;
                this.attackRange = this.job === PLAYER_CLASSES['Archer'] || this.job === PLAYER_CLASSES['Mage'] ? ATTACK_RANGE_RANGED : ATTACK_RANGE_MELEE;
                this.attackCooldown = 0;
                this.target = null;
                this.isAlive = true;
                this.element = null; 
                this.vx = (Math.random() - 0.5) * 2 * this.speed; 
                this.vy = (Math.random() - 0.5) * 2 * this.speed;
                this.path = []; 
                this.pathfindingCooldown = 0;
                this.hitEffectTimer = 0; 
                this.kills = 0; 
                this.damageDealt = 0; 
                this.isEvading = false; 
                this.evadeTimer = 0;
                this.lastAttacker = null; 
                this.attackLungeTimer = 0; 
                this.activeItemEffects = {}; 
                this.ultimateCharge = 0;
                this.ultimateCooldown = 0;
                this.isUltimateActive = false;
                this.ultimateTimer = 0;
                this.survivalTime = 0; 
                this.itemsUsed = 0; 
                this.ultimatesUsed = 0; 
                this.isInPit = false; 
                this.pitDamageTimer = 0;
                this.isOnSwamp = false;
                this.speedPadEffectTimer = 0;
                this.berserkerAttackAnimTimer = 0; 
                this.mageCastAnimTimer = 0; 
            }

            draw() { 
                if (!this.isAlive) return; 

                let displayColor = this.originalColor;
                if (this.isHiding) { 
                    ctx.globalAlpha = 0.5;
                }

                if (this.isUltimateActive) {
                    displayColor = `hsl(${ (Date.now()/10) % 360 }, 100%, 70%)`;
                } else if (this.hitEffectTimer > 0) {
                    displayColor = `rgba(255, 0, 0, ${0.5 + (this.hitEffectTimer / 10) * 0.5})`; 
                    this.hitEffectTimer--;
                } else if (this.activeItemEffects['speedBoost'] > 0 || this.speedPadEffectTimer > 0) {
                    displayColor = 'skyblue'; 
                } else if (this.activeItemEffects['attackBoost'] > 0) {
                    displayColor = 'orange'; 
                }

                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = displayColor;
                ctx.fill();
                ctx.strokeStyle = 'rgba(255,255,255,0.7)'; 
                ctx.lineWidth = 1.5;
                ctx.stroke();
                ctx.closePath();
                
                // 원형 궁극기 게이지
                if (this.ultimateCharge > 0) {
                    ctx.save();
                    ctx.lineWidth = 3; 
                    ctx.strokeStyle = '#ff00ff'; 
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius + 4, -Math.PI / 2, -Math.PI / 2 + (this.ultimateCharge / ULTIMATE_CHARGE_MAX) * (Math.PI * 2), false);
                    ctx.stroke();
                    ctx.restore();
                }
                
                ctx.globalAlpha = 1; 

                // 직업 아이콘 그리기
                ctx.save();
                const iconDrawSize = this.radius * 0.8; 
                const iconLineWidth = 1.5;
                const iconYOffset = -this.radius * 0.1; 

                if (this.job === PLAYER_CLASSES['Brawler']) { 
                    ctx.fillStyle = '#909090'; 
                    ctx.strokeStyle = '#505050';
                    ctx.lineWidth = iconLineWidth;
                    const shieldW = iconDrawSize * 0.7;
                    const shieldH = iconDrawSize * 0.9;
                    ctx.beginPath();
                    ctx.rect(this.x - shieldW / 2, this.y + iconYOffset - shieldH / 2, shieldW, shieldH * 0.7); 
                    ctx.moveTo(this.x - shieldW / 2, this.y + iconYOffset - shieldH / 2 + shieldH * 0.7);
                    ctx.quadraticCurveTo(this.x, this.y + iconYOffset + shieldH * 0.3, this.x + shieldW / 2, this.y + iconYOffset - shieldH / 2 + shieldH * 0.7);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                } else if (this.job === PLAYER_CLASSES['Berserker']) { 
                    ctx.fillStyle = '#e04040'; 
                    ctx.strokeStyle = '#a00000';
                    ctx.lineWidth = iconLineWidth;
                    const hornH = iconDrawSize * 0.6;
                    ctx.beginPath();
                    ctx.moveTo(this.x - this.radius * 0.25, this.y + iconYOffset - this.radius * 0.3);
                    ctx.lineTo(this.x - this.radius * 0.45, this.y + iconYOffset - this.radius * 0.3 - hornH);
                    ctx.lineTo(this.x - this.radius * 0.05, this.y + iconYOffset - this.radius * 0.3 - hornH * 0.5);
                    ctx.closePath();
                    ctx.fill(); ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(this.x + this.radius * 0.25, this.y + iconYOffset - this.radius * 0.3);
                    ctx.lineTo(this.x + this.radius * 0.45, this.y + iconYOffset - this.radius * 0.3 - hornH);
                    ctx.lineTo(this.x + this.radius * 0.05, this.y + iconYOffset - this.radius * 0.3 - hornH * 0.5);
                    ctx.closePath();
                    ctx.fill(); ctx.stroke();
                } else if (this.job === PLAYER_CLASSES['Archer']) { 
                    ctx.strokeStyle = '#4CAF50'; 
                    ctx.lineWidth = iconLineWidth;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y + iconYOffset + iconDrawSize * 0.1, iconDrawSize * 0.6, Math.PI * 0.7, Math.PI * 0.3, false); 
                    ctx.moveTo(this.x - iconDrawSize*0.55, this.y + iconYOffset - iconDrawSize*0.3); 
                    ctx.lineTo(this.x + iconDrawSize*0.55, this.y + iconYOffset - iconDrawSize*0.3);
                    ctx.stroke();
                } else if (this.job === PLAYER_CLASSES['Mage']) { 
                    ctx.fillStyle = '#5c85d6'; 
                    ctx.strokeStyle = '#3366cc';
                    ctx.lineWidth = iconLineWidth;
                    const spikes = 5;
                    const outerR = iconDrawSize * 0.5;
                    const innerR = iconDrawSize * 0.2;
                    let rot = Math.PI / 2 * 3;
                    const cx_s = this.x; 
                    const cy_s = this.y + iconYOffset; 
                    
                    ctx.beginPath();
                    ctx.moveTo(cx_s, cy_s - outerR);
                    for (let i = 0; i < spikes; i++) {
                        let x1 = cx_s + Math.cos(rot) * outerR;
                        let y1 = cy_s + Math.sin(rot) * outerR;
                        ctx.lineTo(x1, y1);
                        rot += Math.PI / spikes;

                        let x2 = cx_s + Math.cos(rot) * innerR;
                        let y2 = cy_s + Math.sin(rot) * innerR;
                        ctx.lineTo(x2, y2);
                        rot += Math.PI / spikes;
                    }
                    ctx.lineTo(cx_s, cy_s - outerR);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                }
                ctx.restore();


                if (this.job === PLAYER_CLASSES['Berserker'] && this.berserkerAttackAnimTimer > 0) {
                    ctx.save();
                    ctx.globalAlpha = this.berserkerAttackAnimTimer / 10 * 0.5; 
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius + (10 - this.berserkerAttackAnimTimer), 0, Math.PI * 2); 
                    ctx.strokeStyle = 'red';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    ctx.restore();
                    this.berserkerAttackAnimTimer--;
                }
                if (this.job === PLAYER_CLASSES['Mage'] && this.mageCastAnimTimer > 0) {
                    ctx.save();
                    const angle = (performance.now() / 100) % (Math.PI * 2);
                    for (let i = 0; i < 3; i++) {
                        const xOff = Math.cos(angle + (i * Math.PI * 2 / 3)) * (this.radius * 1.5);
                        const yOff = Math.sin(angle + (i * Math.PI * 2 / 3)) * (this.radius * 1.5);
                        ctx.beginPath();
                        ctx.arc(this.x + xOff, this.y + yOff, this.radius / 3, 0, Math.PI * 2);
                        ctx.fillStyle = `rgba(180, 180, 255, ${0.3 + (this.mageCastAnimTimer / 15 * 0.4)})`;
                        ctx.fill();
                    }
                    ctx.restore();
                    this.mageCastAnimTimer--;
                }


                const hpBarWidth = this.radius * 2.5;
                const hpBarHeight = 5;
                const nameY = Math.max(NAME_OFFSET_Y + this.radius, this.y - this.radius - NAME_OFFSET_Y); 
                const hpBarActualY = Math.max(HP_BAR_OFFSET_Y + this.radius + hpBarHeight, this.y - this.radius - HP_BAR_OFFSET_Y);


                ctx.fillStyle = 'white';
                ctx.font = '14px Noto Sans KR'; 
                ctx.textAlign = 'center';
                ctx.shadowColor = 'black'; 
                ctx.shadowBlur = 4; 
                ctx.fillText(this.name, this.x, nameY); 
                
                ctx.shadowBlur = 0; 

                const hpBarX = this.x - hpBarWidth / 2;
                ctx.fillStyle = '#333';
                ctx.fillRect(hpBarX, hpBarActualY, hpBarWidth, hpBarHeight);
                ctx.strokeStyle = 'rgba(0,0,0,0.5)'; ctx.lineWidth = 0.5; ctx.strokeRect(hpBarX, hpBarActualY, hpBarWidth, hpBarHeight); 
                const currentHpWidth = (this.hp / this.maxHp) * hpBarWidth;
                ctx.fillStyle = this.hp < this.maxHp * 0.3 ? '#f44336' : (this.hp < this.maxHp * 0.6 ? '#ffc107' : '#4caf50'); 
                ctx.fillRect(hpBarX, hpBarActualY, currentHpWidth, hpBarHeight);
            }

            update(players, worldGridRef, itemsArr, deltaTime) { 
                if (!this.isAlive) return;
                
                this.survivalTime += deltaTime; 

                for (const effect in this.activeItemEffects) {
                    if (this.activeItemEffects[effect] > 0) {
                        this.activeItemEffects[effect] -= 1 * deltaTime;
                        if (this.activeItemEffects[effect] <= 0) {
                            this.removeItemEffect(effect); 
                        }
                    }
                }
                if (this.ultimateCooldown > 0) this.ultimateCooldown -= 1 * deltaTime;
                if (this.isUltimateActive && this.ultimateTimer > 0) {
                    this.ultimateTimer -= 1 * deltaTime;
                    if (this.ultimateTimer <= 0) this.deactivateUltimate();
                }
                if (this.speedPadEffectTimer > 0) {
                    this.speedPadEffectTimer -= 1 * deltaTime;
                    if (this.speedPadEffectTimer <= 0) {
                        logBattleMessage(`${this.name}의 가속 발판 효과가 사라졌습니다.`, 'log-terrain');
                    }
                }


                if (this.attackCooldown > 0) this.attackCooldown -= 1 * deltaTime;
                if (this.pathfindingCooldown > 0) this.pathfindingCooldown -= 1 * deltaTime;
                if (this.evadeTimer > 0) this.evadeTimer -= 1 * deltaTime; else this.isEvading = false;
                if (this.attackLungeTimer > 0) this.attackLungeTimer -= 1 * deltaTime;

                this.checkTerrainEffects(deltaTime);

                this.isHiding = false; 
                let closestBush = null;
                let minDistToBush = Infinity;

                if (this.hp < this.maxHp * 0.4) { 
                    let closestHealthItem = null;
                    let minDistToHealthItem = Infinity;
                    itemsArr.forEach(item => {
                        if (item.type === 'health') {
                            const dist = Math.hypot(this.x - item.x, this.y - item.y);
                            if (dist < minDistToHealthItem) {
                                minDistToHealthItem = dist;
                                closestHealthItem = item;
                            }
                        }
                    });
                    if (closestHealthItem) {
                        this.target = closestHealthItem; 
                        this.targetItem = closestHealthItem; 
                    } else {
                        this.findTarget(players, allPlayers); 
                        this.targetItem = null;
                    }
                } else if (!this.target || !this.target.isAlive || (this.targetItem && !items.includes(this.targetItem))) { 
                    obstacles.forEach(obs => {
                        if (obs.type === 'bush') {
                            const dist = Math.hypot(this.x - (obs.x + obs.width/2), this.y - (obs.y + obs.height/2));
                            if (dist < minDistToBush) {
                                minDistToBush = dist;
                                closestBush = obs;
                            }
                        }
                    });

                    if (closestBush && minDistToBush < this.attackRange * 1.5 && Math.random() < 0.25 && this.hp > this.maxHp * 0.6) { 
                        this.target = { x: closestBush.x + closestBush.width/2, y: closestBush.y + closestBush.height/2, isAlive: false, type: 'bush' };
                        this.targetItem = null;
                        if (minDistToBush < this.radius + closestBush.width/2) { 
                            this.isHiding = true;
                            this.attackRange = ATTACK_RANGE_MELEE * 0.6; 
                        }
                    } else {
                        this.attackRange = this.job === PLAYER_CLASSES['Archer'] || this.job === PLAYER_CLASSES['Mage'] ? ATTACK_RANGE_RANGED : ATTACK_RANGE_MELEE; 
                        let closestSpeedPad = null;
                        let minDistToSpeedPad = Infinity;
                        obstacles.forEach(obs => {
                            if (obs.type === 'speed_pad') {
                                const dist = Math.hypot(this.x - (obs.x + obs.width/2), this.y - (obs.y + obs.height/2));
                                 if (dist < minDistToSpeedPad && dist < this.attackRange * 2) { 
                                    minDistToSpeedPad = dist;
                                    closestSpeedPad = obs;
                                }
                            }
                        });
                        if (closestSpeedPad && this.speedPadEffectTimer <= 0 && Math.random() < 0.3) { 
                            this.target = { x: closestSpeedPad.x + closestSpeedPad.width/2, y: closestSpeedPad.y + closestSpeedPad.height/2, isAlive: false, type: 'speed_pad' }; 
                            this.targetItem = null;
                        } else {
                            this.findTarget(players, allPlayers);
                            this.targetItem = null;
                        }
                    }
                } else {
                     this.findTarget(players, allPlayers);
                     this.targetItem = null;
                }


                this.move(worldGridRef, deltaTime); 
                this.checkForItemPickup(itemsArr);

                if (this.ultimateCharge >= ULTIMATE_CHARGE_MAX && this.ultimateCooldown <= 0 && !this.isUltimateActive) {
                    this.activateUltimate(players);
                }


                if (this.target && this.target.isAlive && !this.isEvading && !this.isUltimateActive) { 
                    const distToTarget = Math.hypot(this.target.x - this.x, this.target.y - this.y);
                    if (distToTarget <= this.attackRange && this.attackCooldown <= 0) {
                        this.attack(this.target);
                    }
                }
                this.updateCardHP();
            }

            checkTerrainEffects(deltaTime) { 
                this.isInPit = false; 
                this.isOnSwamp = false;
                let currentSpeedFactor = 1.0;

                if (this.speedPadEffectTimer > 0) {
                    currentSpeedFactor *= SPEED_PAD_BOOST_FACTOR;
                }

                for (const obs of obstacles) {
                    if (obs.type === 'pit') {
                        const distToPitCenter = Math.hypot(this.x - (obs.x + obs.width / 2), this.y - (obs.y + obs.height / 2));
                        if (distToPitCenter < obs.radius) { 
                            this.isInPit = true;
                            currentSpeedFactor *= PIT_SLOW_FACTOR; 
                            this.pitDamageTimer += deltaTime;
                            if (this.pitDamageTimer >= 60 / gameSpeedMultiplier) { 
                                this.takeDamage(PIT_DAMAGE * 60, {name: "구덩이"}); 
                                this.pitDamageTimer = 0;
                                logBattleMessage(`${this.name}이(가) 구덩이에 빠져 허우적댑니다! (-${(PIT_DAMAGE * 60).toFixed(1)} HP)`, 'log-pit');
                            }
                        }
                    } else if (obs.type === 'swamp') {
                        if (this.x > obs.x && this.x < obs.x + obs.width && this.y > obs.y && this.y < obs.y + obs.height) {
                            this.isOnSwamp = true;
                            currentSpeedFactor *= SWAMP_SLOW_FACTOR;
                            if (Math.random() < 0.005 * deltaTime) { 
                                logBattleMessage(`${this.name}이(가) 늪에 빠져 이동이 느려집니다!`, 'log-terrain');
                            }
                        }
                    } else if (obs.type === 'speed_pad') {
                         if (this.x > obs.x && this.x < obs.x + obs.width && this.y > obs.y && this.y < obs.y + obs.height && this.speedPadEffectTimer <=0) {
                            this.speedPadEffectTimer = SPEED_PAD_DURATION / gameSpeedMultiplier;
                            logBattleMessage(`💨 ${this.name}이(가) 가속 발판을 밟아 빨라집니다!`, 'log-terrain');
                         }
                    } else if (obs.type === 'lava_pool') { 
                         const distToLavaCenter = Math.hypot(this.x - (obs.x + obs.width / 2), this.y - (obs.y + obs.height / 2));
                         if (distToLavaCenter < obs.radius) {
                            this.pitDamageTimer += deltaTime; 
                            if (this.pitDamageTimer >= (60 / gameSpeedMultiplier) * 0.5) { 
                                const lavaDmg = PLAYER_HP_BASE * 0.02; 
                                this.takeDamage(lavaDmg, {name: "용암"});
                                this.pitDamageTimer = 0;
                                logBattleMessage(`${this.name}이(가) 용암에 발을 디뎌 화상을 입습니다! (-${lavaDmg.toFixed(1)} HP)`, 'log-terrain');
                                for(let i=0; i<2; i++) particles.push(new Particle(this.x + (Math.random()-0.5)*this.radius, this.y + (Math.random()-0.5)*this.radius, 'orangered', 2, 15, (Math.random()-0.5)*1, -Math.random()*2)); 
                            }
                         }
                    }
                }
                let baseSpeedForCalc = PLAYER_SPEED_BASE_VAL;
                if (this.perk === 'swiftness') baseSpeedForCalc *= 1.10;

                this.speed = baseSpeedForCalc * currentSpeedFactor * (this.activeItemEffects['speedBoost'] > 0 ? 1.5 : 1);
                if (!this.isInPit && !this.isOnSwamp) this.pitDamageTimer = 0; 
            }
            
            findTarget(players, allPlayersRef) { 
                let bestTarget = null;
                let highestScore = -Infinity;
                const alivePlayerCount = players.filter(p => p.isAlive).length;

                let teamAttacker = null;
                allPlayersRef.forEach(ally => {
                    if (ally.baseName === this.baseName && ally !== this && ally.lastAttacker && ally.lastAttacker.isAlive && ally.lastAttacker !== this) {
                        if (!teamAttacker || ally.lastAttacker.hp < teamAttacker.hp) { 
                            teamAttacker = ally.lastAttacker;
                        }
                    }
                });
                if (teamAttacker) {
                    this.target = teamAttacker;
                    return;
                }


                players.forEach(p => {
                    if (p === this || !p.isAlive) return;
                    if (p.baseName === this.baseName && p.id !== this.id) return; 
                    
                    let score = 0;
                    const distance = Math.hypot(this.x - p.x, this.y - p.y);
                    score += (gameCanvasEl.width - distance) / 10; 
                    score += (PLAYER_HP_BASE - p.hp) / 2; 
                    if (p === this.lastAttacker && this.lastAttacker.isAlive) {
                        score += 50; 
                    }
                    if (p === this.target) {
                        score += 20;
                    }

                    if (alivePlayerCount > 3 && p.hp > PLAYER_HP_BASE * 0.7) {
                        score += 30; 
                    }


                    if (score > highestScore) {
                        highestScore = score;
                        bestTarget = p;
                    }
                });
                this.target = bestTarget;
            }

            move(worldGridRef, deltaTime) { 
                let targetVx = 0;
                let targetVy = 0;
                const currentSpeed = this.speed * deltaTime; 

                if (this.isEvading && this.lastAttacker && this.lastAttacker.isAlive) { 
                    const angleFromAttacker = Math.atan2(this.y - this.lastAttacker.y, this.x - this.lastAttacker.x);
                    targetVx = Math.cos(angleFromAttacker) * currentSpeed * 1.2; 
                    targetVy = Math.sin(angleFromAttacker) * currentSpeed * 1.2;
                } else if (this.attackLungeTimer > 0 && this.target && this.target.isAlive) { 
                     const angleToTarget = Math.atan2(this.target.y - this.y, this.target.x - this.x);
                     targetVx = Math.cos(angleToTarget) * currentSpeed * 1.5; 
                     targetVy = Math.sin(angleToTarget) * currentSpeed * 1.5;
                }
                else if (this.target) { 
                    let targetX = this.target.x;
                    let targetY = this.target.y;
                    if (this.targetItem) { 
                        targetX = this.targetItem.x;
                        targetY = this.targetItem.y;
                    } else if (this.target.type === 'bush' || this.target.type === 'speed_pad') { 
                        targetX = this.target.x;
                        targetY = this.target.y;
                    }


                    if (this.pathfindingCooldown <= 0 && worldGridRef && worldGridRef.length > 0 && worldGridRef[0] && worldGridRef[0].length > 0) {
                        const startGridX = Math.max(0, Math.min(Math.floor(this.x / GRID_CELL_SIZE), worldGridRef[0].length -1));
                        const startGridY = Math.max(0, Math.min(Math.floor(this.y / GRID_CELL_SIZE), worldGridRef.length -1));
                        const endGridX = Math.max(0, Math.min(Math.floor(targetX / GRID_CELL_SIZE), worldGridRef[0].length -1));
                        const endGridY = Math.max(0, Math.min(Math.floor(targetY / GRID_CELL_SIZE), worldGridRef.length -1));
                        
                        if (worldGridRef[startGridY][startGridX] === 1) { 
                             this.path = [];
                        } else if (startGridX !== endGridX || startGridY !== endGridY) {
                            this.path = aStar(startGridX, startGridY, endGridX, endGridY, worldGridRef);
                        } else { this.path = []; }
                        
                        this.pathfindingCooldown = PATHFINDING_COOLDOWN_BASE / gameSpeedMultiplier; 
                    }

                    if (this.path.length > 0) {
                        const nextWaypointGrid = this.path[0];
                        const nextWaypointX = nextWaypointGrid.x * GRID_CELL_SIZE + GRID_CELL_SIZE / 2;
                        const nextWaypointY = nextWaypointGrid.y * GRID_CELL_SIZE + GRID_CELL_SIZE / 2;
                        const angleToWaypoint = Math.atan2(nextWaypointY - this.y, nextWaypointX - this.x);
                        targetVx = Math.cos(angleToWaypoint) * currentSpeed;
                        targetVy = Math.sin(angleToWaypoint) * currentSpeed;
                        if (Math.hypot(nextWaypointX - this.x, nextWaypointY - this.y) < this.radius * 1.5) {
                            this.path.shift();
                        }
                    } else { 
                        const angleToTarget = Math.atan2(targetY - this.y, targetX - this.x);
                        targetVx = Math.cos(angleToTarget) * currentSpeed;
                        targetVy = Math.sin(angleToTarget) * currentSpeed;
                    }
                } else { 
                    if (Math.random() < 0.02 || (this.vx === 0 && this.vy === 0) ) { 
                        this.vx = (Math.random() - 0.5) * 2 * currentSpeed * 0.7; 
                        this.vy = (Math.random() - 0.5) * 2 * currentSpeed * 0.7;
                    }
                    targetVx = this.vx; targetVy = this.vy;
                }
                
                let nextX = this.x + targetVx;
                let nextY = this.y + targetVy;

                for (const obs of obstacles) {
                    if (obs.type === 'pit' || obs.type === 'swamp' || obs.type === 'speed_pad' || obs.type === 'lava_pool') continue; 

                    const playerRect = { x: nextX - this.radius, y: nextY - this.radius, width: this.radius * 2, height: this.radius * 2 };
                    const obsRect = { x: obs.x, y: obs.y, width: obs.width, height: obs.height };

                    if (playerRect.x < obsRect.x + obsRect.width &&
                        playerRect.x + playerRect.width > obsRect.x &&
                        playerRect.y < obsRect.y + obsRect.height &&
                        playerRect.y + playerRect.height > obsRect.y) {
                        
                        const dx = (this.x - (obs.x + obs.width / 2)); 
                        const dy = (this.y - (obs.y + obs.height / 2));
                        const combinedHalfWidths = this.radius + obs.width / 2;
                        const combinedHalfHeights = this.radius + obs.height / 2;
                        const overlapX = combinedHalfWidths - Math.abs(dx);
                        const overlapY = combinedHalfHeights - Math.abs(dy);

                        if (overlapX > 0 && overlapY > 0) {
                            if (overlapX < overlapY) {
                                if (dx > 0) nextX = obs.x + obs.width + this.radius + 0.1; 
                                else nextX = obs.x - this.radius - 0.1; 
                                this.vx *= -0.1; 
                                targetVx = 0; 
                            } else {
                                if (dy > 0) nextY = obs.y + obs.height + this.radius + 0.1; 
                                else nextY = obs.y - this.radius - 0.1; 
                                this.vy *= -0.1;
                                targetVy = 0;
                            }
                            this.path = [];
                            this.pathfindingCooldown = 0;
                        }
                    }
                }


                if (nextX - this.radius < 0) { nextX = this.radius; this.vx *= -0.5; } 
                if (nextX + this.radius > gameCanvasEl.width) { nextX = gameCanvasEl.width - this.radius; this.vx *= -0.5; }
                if (nextY - this.radius < 0) { nextY = this.radius; this.vy *= -0.5; }
                if (nextY + this.radius > gameCanvasEl.height) { nextY = gameCanvasEl.height - this.radius; this.vy *= -0.5; }
                
                this.x = nextX; this.y = nextY;
            }

            attack(target) {
                const damageDealt = this.attackPower * (this.activeItemEffects['attackBoost'] > 0 ? 1.5 : 1); 
                target.takeDamage(damageDealt, this); 
                this.damageDealt += damageDealt; 
                this.ultimateCharge = Math.min(ULTIMATE_CHARGE_MAX, this.ultimateCharge + ULTIMATE_CHARGE_PER_HIT);
                this.attackCooldown = ATTACK_COOLDOWN_BASE / gameSpeedMultiplier;
                this.attackLungeTimer = 5 / gameSpeedMultiplier; 
                
                if (this.job === PLAYER_CLASSES['Archer']) {
                    attackEffects.push(new AttackEffect(this.x, this.y, target.x, target.y, 'lightgray', 1, 3, 'projectile', {trail: true, sizeFactor: 2.5, speed: 18}));
                } else if (this.job === PLAYER_CLASSES['Mage']) {
                    this.mageCastAnimTimer = 15 / gameSpeedMultiplier; 
                    attackEffects.push(new AttackEffect(this.x, this.y, target.x, target.y, 'violet', 1, 3, 'magic_bolt'));
                } else if (this.job === PLAYER_CLASSES['Brawler']) {
                    attackEffects.push(new AttackEffect(this.x, this.y, target.x, target.y, 'rgba(255, 100, 80, 0.9)', 2, 5, 'slash', {radius: PLAYER_RADIUS * 1.8}));
                    if (Math.random() < 0.3) { 
                        target.takeKnockback(this.x, this.y, 30);
                        logBattleMessage(`${this.name}이(가) ${target.name}을(를) 강타하여 밀쳐냈습니다!`, 'log-event');
                    }
                } else if (this.job === PLAYER_CLASSES['Berserker']) {
                    this.berserkerAttackAnimTimer = 10 / gameSpeedMultiplier; 
                    attackEffects.push(new AttackEffect(this.x, this.y, target.x, target.y, 'rgba(255, 0, 0, 0.7)', 3, 6, 'slash', {radius: PLAYER_RADIUS * 2.2}));
                } else { 
                    attackEffects.push(new AttackEffect(this.x, this.y, target.x, target.y, 'rgba(255, 80, 80, 0.9)'));
                }


                this.isEvading = true;
                this.evadeTimer = EVADE_DURATION_BASE / gameSpeedMultiplier;
                this.lastAttacker = target; 
            }

            takeKnockback(attackerX, attackerY, power) {
                const angle = Math.atan2(this.y - attackerY, this.x - attackerX);
                this.vx += Math.cos(angle) * power / (5 * gameSpeedMultiplier); 
                this.vy += Math.sin(angle) * power / (5 * gameSpeedMultiplier);
                this.path = []; 
            }


            takeDamage(damage, attacker) {
                this.hp -= damage;
                this.hitEffectTimer = 8; 
                this.lastAttacker = attacker; 

                if (this.element) { 
                    this.element.style.transition = 'background-color 0.05s'; 
                    this.element.style.backgroundColor = '#b71c1c'; 
                    setTimeout(() => {
                        if (this.element && this.isAlive) this.element.style.backgroundColor = '#3a3a4e';
                    }, 50);
                }
                if (this.hp <= 0) {
                    this.hp = 0;
                    if (this.isAlive) { 
                        this.isAlive = false;
                        if (attacker && attacker.kills !== undefined) { 
                            attacker.kills++; 
                            attacker.ultimateCharge = Math.min(ULTIMATE_CHARGE_MAX, attacker.ultimateCharge + ULTIMATE_CHARGE_PER_KILL);
                        }
                        logBattleMessage(`💥 ${this.name} 플레이어가 ${attacker.name}의 공격에 결정타를 맞고 탈락했습니다!`, 'log-event');
                        if (this.element) {
                            this.element.classList.add('eliminated');
                        }
                        for (let i = 0; i < 25; i++) { 
                            particles.push(new Particle(this.x, this.y, this.originalColor));
                        }
                    }
                }
                this.updateCardHP();
            }
            
            checkForItemPickup(itemsArr) {
                for (let i = itemsArr.length - 1; i >= 0; i--) {
                    const item = itemsArr[i];
                    const distToItem = Math.hypot(item.x - this.x, item.y - this.y);
                    if (distToItem < this.radius + item.radius) {
                        this.applyItemEffect(item);
                        itemsArr.splice(i, 1); 
                        break;
                    }
                }
            }

            applyItemEffect(item) {
                this.itemsUsed++; 
                if (item.type === 'health') {
                    this.hp = Math.min(this.maxHp, this.hp + 35); 
                    logBattleMessage(`💚 ${this.name} 플레이어가 구급상자를 발견하여 체력을 회복합니다! (HP: ${this.hp.toFixed(0)})`, 'log-item');
                } else if (item.type === 'speedBoost') {
                    this.activeItemEffects['speedBoost'] = ITEM_EFFECT_DURATION_BASE / gameSpeedMultiplier;
                    logBattleMessage(`⚡ ${this.name} 플레이어가 스피드 부스트를 획득! 이동 속도가 빨라집니다!`, 'log-item');
                } else if (item.type === 'attackBoost') {
                    this.activeItemEffects['attackBoost'] = ITEM_EFFECT_DURATION_BASE / gameSpeedMultiplier;
                    logBattleMessage(`🔥 ${this.name} 플레이어가 공격력 강화 아이템을 획득! 공격력이 강력해집니다!`, 'log-item');
                }
                this.updateCardHP();
            }

            removeItemEffect(effectType) {
                if (effectType === 'speedBoost') {
                    logBattleMessage(`💨 ${this.name} 플레이어의 스피드 부스트 효과가 종료되었습니다.`, 'log-item');
                } else if (effectType === 'attackBoost') {
                    logBattleMessage(`⚔️ ${this.name} 플레이어의 공격력 강화 효과가 종료되었습니다.`, 'log-item');
                }
            }

            activateUltimate(players) {
                this.isUltimateActive = true;
                this.ultimateTimer = ULTIMATE_DURATION_BASE / gameSpeedMultiplier; 
                this.ultimateCharge = 0;
                this.ultimateCooldown = ULTIMATE_COOLDOWN_BASE / gameSpeedMultiplier; 
                this.ultimatesUsed++; 
                let ultimateName = "필살기";
                let ultimateDamage = this.attackPower * 1.5 * (this.activeItemEffects['attackBoost'] > 0 ? 1.5 : 1); 
                const ultimateRange = this.radius * 6;

                if (this.job === PLAYER_CLASSES['Brawler']) {
                    ultimateName = "<<지각 변동>>";
                    ultimateDamage = this.attackPower * 1.2 * (this.activeItemEffects['attackBoost'] > 0 ? 1.5 : 1);
                    logBattleMessage(`🔨 ${this.name}(${this.job})의 필살기 ${ultimateName}! 주변 모든 적을 밀쳐내고 기절시킵니다!`, 'log-ultimate');
                    attackEffects.push({ 
                        x: this.x, y: this.y, radius: 0, maxRadius: ultimateRange * 1.2, 
                        duration: 30 / gameSpeedMultiplier, currentFrame: 0, 
                        color: 'rgba(200, 100, 50, 0.7)', type: 'wave',
                        lineWidth: 8,
                        update: function(dt) { this.currentFrame+=dt; this.radius = (this.currentFrame / this.duration) * this.maxRadius; },
                        draw: function() { 
                            if (this.currentFrame >= this.duration) return; 
                            ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); 
                            ctx.strokeStyle = this.color; ctx.lineWidth = this.lineWidth * (1 - this.currentFrame/this.duration); 
                            ctx.globalAlpha = 0.8 * (1 - this.currentFrame/this.duration);
                            ctx.stroke(); 
                            ctx.globalAlpha = 1;
                        }
                    });
                    attackEffects.push(new AttackEffect(this.x, this.y, 0, 0, 'rgba(255,150,50,0.4)', 0, 0, 'aura', {maxRadius: this.radius * 2.5, duration: 20, opacity: 0.6}));

                    players.forEach(p => {
                        if (p !== this && p.isAlive) {
                            const distance = Math.hypot(this.x - p.x, this.y - p.y);
                            if (distance <= ultimateRange) {
                                p.takeDamage(ultimateDamage, this);
                                p.takeKnockback(this.x, this.y, 80); 
                                p.evadeTimer = 90 / gameSpeedMultiplier; 
                            }
                        }
                    });
                } else if (this.job === PLAYER_CLASSES['Berserker']) {
                    ultimateName = "<<광전사의 분노>>";
                    logBattleMessage(`😡 ${this.name}(${this.job})의 필살기 ${ultimateName}! 공격력과 속도가 폭주합니다!`, 'log-ultimate');
                    for(let i=0; i<10; i++) { 
                        particles.push(new Particle(this.x, this.y, 'red', 3, 30, (Math.random()-0.5)*6, (Math.random()-0.5)*6));
                    }
                } else if (this.job === PLAYER_CLASSES['Archer']) {
                    ultimateName = "<<화살 폭풍>>";
                    logBattleMessage(`🏹 ${this.name}(${this.job})의 필살기 ${ultimateName}! 여러 방향으로 강화된 화살을 난사합니다!`, 'log-ultimate');
                    const numArrows = 12;
                    for (let i = 0; i < numArrows; i++) { 
                        const angle = (i / numArrows) * Math.PI * 2 + (Math.random() - 0.5) * 0.2; 
                        const endX = this.x + Math.cos(angle) * ATTACK_RANGE_RANGED * 1.2; 
                        const endY = this.y + Math.sin(angle) * ATTACK_RANGE_RANGED * 1.2;
                        attackEffects.push(new AttackEffect(this.x, this.y, endX, endY, 'cyan', 2, 8, 'projectile', {trail: true, sizeFactor: 1.8, speed: 22, shadow: 12}));
                        players.forEach(p => { 
                            if (p !== this && p.isAlive && Math.hypot(p.x - this.x, p.y - this.y) < ATTACK_RANGE_RANGED * 0.8) { 
                                p.takeDamage(this.attackPower * 0.6 * (this.activeItemEffects['attackBoost'] > 0 ? 1.5 : 1), this); 
                            }
                        });
                    }
                } else if (this.job === PLAYER_CLASSES['Mage']) {
                    ultimateName = "<<얼음 폭풍>>";
                    const stormRadius = this.radius * 12; 
                    logBattleMessage(`❄️ ${this.name}(${this.job})의 필살기 ${ultimateName}! 지정 범위에 강력한 얼음 폭풍을 소환합니다!`, 'log-ultimate');
                     attackEffects.push({ 
                        x: this.x, y: this.y, radius: stormRadius, 
                        duration: ULTIMATE_DURATION_BASE / gameSpeedMultiplier, currentFrame: 0, 
                        color: 'rgba(100, 150, 255, 0.2)', type: 'static_aoe',
                        update: function(dt) { this.currentFrame+=dt; },
                        draw: function() { 
                            if (this.currentFrame >= this.duration) return;
                            const alphaBase = 0.2;
                            const pulse = Math.sin(this.currentFrame * 0.1) * 0.1;
                            ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); 
                            ctx.fillStyle = `rgba(100, 150, 255, ${alphaBase + pulse})`; ctx.fill(); 
                            if (this.currentFrame % (10 / gameSpeedMultiplier) < 1) { 
                                for(let i=0; i < 3; i++) {
                                    const rA = Math.random() * Math.PI * 2;
                                    const rD = Math.random() * this.radius * 0.8;
                                    particles.push(new Particle(this.x + Math.cos(rA)*rD, this.y + Math.sin(rA)*rD, 'white', Math.random()*1.5+0.5, 15, 0,0));
                                }
                            }
                        }
                    });
                    players.forEach(p => {
                        if (p !== this && p.isAlive) {
                            const distance = Math.hypot(this.x - p.x, this.y - p.y);
                            if (distance <= stormRadius) {
                                p.takeDamage(ultimateDamage * 0.15, this); 
                                p.speed *= 0.6; 
                                setTimeout(() => { if(p.isAlive) p.speed = PLAYER_SPEED_BASE_VAL * (p.perk === 'swiftness' ? 1.10 : 1) ; }, ULTIMATE_DURATION_BASE / gameSpeedMultiplier * 1000/60); 
                            }
                        }
                    });
                }
            }
            deactivateUltimate() {
                this.isUltimateActive = false;
                logBattleMessage(`✨ ${this.name} 플레이어의 필살기 효과가 종료되었습니다.`, 'log-ultimate');
            }
            
            updateCardHP() {
                if (this.element) {
                    const hpBar = this.element.querySelector('.hp-bar');
                    if (hpBar) {
                        hpBar.style.width = `${(this.hp / this.maxHp) * 100}%`;
                    }
                    if (this.hp < this.maxHp * 0.3) {
                        this.element.classList.add('low-hp');
                    } else {
                        this.element.classList.remove('low-hp');
                    }
                }
            }
        }

        // 아이템 클래스 (이전과 동일)
        class Item {
            constructor(x, y, type) {
                this.x = x; this.y = y; this.radius = ITEM_RADIUS;
                this.type = type; 
                this.pulseSize = Math.random() * Math.PI; 
                this.pulseSpeed = 0.08 + Math.random() * 0.04; 
                switch(type) {
                    case 'health': this.color = 'lime'; this.symbol = '✚'; break;
                    case 'speedBoost': this.color = 'deepskyblue'; this.symbol = '⚡'; break;
                    case 'attackBoost': this.color = 'orangered'; this.symbol = '🔥'; break;
                    default: this.color = 'gold'; this.symbol = '?';
                }
            }
            update(deltaTime) { 
                this.pulseSize += this.pulseSpeed * deltaTime;
                if (this.pulseSize > Math.PI * 2) this.pulseSize = 0;
            }
            draw() {
                const currentRadius = this.radius + Math.sin(this.pulseSize) * 2; 
                ctx.beginPath(); ctx.arc(this.x, this.y, currentRadius, 0, Math.PI * 2);
                ctx.fillStyle = this.color; 
                ctx.shadowColor = this.color; ctx.shadowBlur = 10;
                ctx.fill(); 
                ctx.shadowBlur = 0; 
                ctx.fillStyle = 'white';
                ctx.font = `${currentRadius * 1.2}px Noto Sans KR`; 
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.symbol, this.x, this.y);
                ctx.closePath();
            }
        }

        // 장애물 클래스 (그래픽 및 다양성 개선)
        class Obstacle {
            constructor(x, y, width, height, type = 'wall', theme = 'default') { 
                this.x = x; this.y = y; this.width = width; this.height = height;
                this.type = type;
                this.theme = theme;
                this.isRound = false;
                this.radius = 0; 
                this.animationOffset = Math.random() * 1000; 
                this.noiseSeed = Math.random() * 10000; 

                switch(type) {
                    case 'pit':
                        this.color = `hsl(210, 35%, ${8 + Math.random()*4}%)`; 
                        this.isRound = true; 
                        this.radius = Math.min(width, height) / 2; 
                        break;
                    case 'swamp':
                        this.color = `hsl(100, 40%, ${18 + Math.random()*7}%)`; 
                        break;
                    case 'speed_pad':
                        this.color = `hsl(180, 85%, 50%)`; 
                        break;
                    case 'bush': 
                        this.color = `hsl(120, 60%, ${22 + Math.random()*8}%)`; 
                        this.leaves = []; 
                        for(let i=0; i<8 + Math.random()*7; i++){ 
                            this.leaves.push({
                                offsetX: (Math.random() - 0.5) * width * 0.7,
                                offsetY: (Math.random() - 0.5) * height * 0.7,
                                radius: Math.random() * (width/4) + (width/8), 
                                color: `hsl(120, 55%, ${25 + Math.random()*20}%)`
                            });
                        }
                        break;
                    case 'lava_pool': 
                        this.color = `hsl(25, 95%, ${30 + Math.random()*8}%)`; 
                        this.isRound = true;
                        this.radius = Math.min(width, height) / 2;
                        break;
                    default: // wall
                        if (theme === 'forest') this.color = `hsl(30, 40%, ${30 + Math.random()*8}%)`; 
                        else if (theme === 'lava') this.color = `hsl(0, 0%, ${12 + Math.random()*4}%)`; 
                        else this.color = `hsl(230, 18%, ${28 + Math.random()*8}%)`; 
                }
            }
            simpleNoise(val) {
                const x = Math.sin(val * 12.9898 + this.noiseSeed) * 43758.5453;
                return (x - Math.floor(x)) * 0.5 + 0.25; 
            }

            draw() {
                ctx.save();
                ctx.fillStyle = this.color; 
                ctx.strokeStyle = `hsl(230, 20%, ${Math.random()*5 + (this.type === 'pit' ? 15 : 40)}%)`; 
                ctx.lineWidth = (this.type === 'pit' || this.type === 'lava_pool' || this.type === 'swamp') ? 0 : 2.5; 

                ctx.beginPath();
                if (this.isRound) { 
                    ctx.arc(this.x + this.width/2, this.y + this.height/2, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                    if (this.type === 'pit') { 
                        for (let i = 1; i < 5; i++) { 
                            ctx.beginPath();
                            ctx.globalAlpha = 0.1 * (5-i);
                            ctx.fillStyle = `hsl(210, 30%, ${3 + i*1.5}%)`;
                            ctx.arc(this.x + this.width/2, this.y + this.height/2, this.radius * (1 - i*0.12), 0, Math.PI * 2);
                            ctx.fill();
                        }
                        ctx.globalAlpha = 1;
                    }
                } else if (this.type === 'speed_pad') { 
                    const r = 10; 
                    ctx.moveTo(this.x + r, this.y); ctx.lineTo(this.x + this.width - r, this.y);
                    ctx.quadraticCurveTo(this.x + this.width, this.y, this.x + this.width, this.y + r);
                    ctx.lineTo(this.x + this.width, this.y + this.height - r);
                    ctx.quadraticCurveTo(this.x + this.width, this.y + this.height, this.x + this.width - r, this.y + this.height);
                    ctx.lineTo(this.x + r, this.y + this.height);
                    ctx.quadraticCurveTo(this.x, this.y + this.height, this.x, this.y + this.height - r);
                    ctx.lineTo(this.x, this.y + r); ctx.quadraticCurveTo(this.x, this.y, this.x + r, this.y);
                    ctx.closePath();
                    ctx.fill();
                    
                    ctx.fillStyle = 'rgba(220, 255, 255, 0.8)'; 
                    const arrowCount = Math.max(1, Math.floor(this.height / 20)); 
                    const arrowHeight = this.height * 0.15;
                    const arrowWidth = this.width * 0.4;
                    const arrowSpacing = this.height / (arrowCount + 1);
                    const animOffset = (performance.now() + this.animationOffset) / 15 % arrowSpacing;
                    for (let i = 0; i < arrowCount + 1; i++) {
                        const yPos = this.y + i * arrowSpacing - animOffset + arrowSpacing / 2;
                        if (yPos > this.y + arrowHeight*0.5 && yPos < this.y + this.height - arrowHeight*0.5) {
                            ctx.beginPath();
                            ctx.moveTo(this.x + this.width / 2 - arrowWidth / 2, yPos + arrowHeight / 2);
                            ctx.lineTo(this.x + this.width / 2 + arrowWidth / 2, yPos + arrowHeight / 2);
                            ctx.lineTo(this.x + this.width / 2, yPos - arrowHeight / 2);
                            ctx.closePath();
                            ctx.fill();
                        }
                    }
                } else { 
                    const r = (this.type === 'bush') ? this.width/2.5 : 6; 
                    ctx.moveTo(this.x + r, this.y); ctx.lineTo(this.x + this.width - r, this.y);
                    ctx.quadraticCurveTo(this.x + this.width, this.y, this.x + this.width, this.y + r);
                    ctx.lineTo(this.x + this.width, this.y + this.height - r);
                    ctx.quadraticCurveTo(this.x + this.width, this.y + this.height, this.x + this.width - r, this.y + this.height);
                    ctx.lineTo(this.x + r, this.y + this.height);
                    ctx.quadraticCurveTo(this.x, this.y + this.height, this.x, this.y + this.height - r);
                    ctx.lineTo(this.x, this.y + r); ctx.quadraticCurveTo(this.x, this.y, this.x + r, this.y);
                    ctx.closePath();
                    ctx.fill();
                    if (this.type !== 'swamp') ctx.stroke(); 

                    if (this.type === 'wall') { 
                        ctx.save();
                        ctx.clip(); 
                        for(let i=0; i< this.width * this.height / 200; i++){ 
                            const tx = this.x + Math.random() * this.width;
                            const ty = this.y + Math.random() * this.height;
                            const brightness = this.simpleNoise(tx * 0.05 + ty * 0.02);
                            ctx.fillStyle = `rgba(0,0,0,${0.08 + brightness * 0.12})`; 
                            ctx.fillRect(tx, ty, 2 + Math.random()*2, 2 + Math.random()*2); 
                        }
                        ctx.restore();
                    }
                     if (this.type === 'bush') { 
                        this.leaves.forEach(leaf => {
                            ctx.beginPath();
                            ctx.fillStyle = leaf.color;
                            ctx.arc(this.x + this.width/2 + leaf.offsetX, this.y + this.height/2 + leaf.offsetY, leaf.radius * (0.8 + Math.random()*0.4) , 0, Math.PI*2); 
                            ctx.fill();
                        });
                    }
                }
                ctx.restore();

                if (this.type === 'lava_pool') { 
                    ctx.save();
                    const numBubbles = 8 + Math.floor(this.radius / 8); 
                    for (let i=0; i<numBubbles; i++) {
                        const angle = (performance.now() / (800 + i*80 + this.animationOffset) + i*0.7) % (Math.PI*2);
                        const dist = Math.random() * this.radius * 0.85;
                        const bubbleX = this.x + this.width/2 + Math.cos(angle) * dist;
                        const bubbleY = this.y + this.height/2 + Math.sin(angle) * dist;
                        const bubbleR = Math.random() * (this.radius/8) + 3; 
                        ctx.globalAlpha = 0.5 + Math.sin(performance.now() / (250 + i*40)) * 0.3;
                        ctx.fillStyle = `hsl(30, 100%, ${60 + Math.random()*10}%)`; 
                        ctx.beginPath();
                        ctx.arc(bubbleX, bubbleY, bubbleR, 0, Math.PI*2);
                        ctx.fill();
                    }
                    ctx.restore();
                } else if (this.type === 'swamp') { 
                    ctx.save();
                     if (Math.random() < 0.04) { 
                        const bubbleX = this.x + Math.random() * this.width;
                        const bubbleY = this.y + Math.random() * this.height;
                        const bubbleR = Math.random() * 4 + 2; 
                        particles.push(new Particle(bubbleX, bubbleY, `hsla(100, 30%, 10%, 0.6)`, bubbleR, 35 + Math.random()*25, 0, -0.15 - Math.random()*0.25));
                    }
                    for(let i=0; i < 5; i++) {
                        ctx.fillStyle = `hsla(100, 30%, ${15 + Math.random()*5}%, ${0.1 + Math.random()*0.1})`;
                        ctx.beginPath();
                        ctx.ellipse(this.x + Math.random()*this.width, this.y + Math.random()*this.height, Math.random()*this.width*0.2, Math.random()*this.height*0.15, Math.random()*Math.PI, 0, Math.PI*2);
                        ctx.fill();
                    }
                    ctx.restore();
                }
            }
        }
        
        // 배경 그리기 함수 (정적 이미지 스타일로 변경)
        function drawBackground(theme) {
            ctx.clearRect(0, 0, gameCanvasEl.width, gameCanvasEl.height);

            if (theme === 'default') {
                const gradient = ctx.createLinearGradient(0, 0, 0, gameCanvasEl.height);
                gradient.addColorStop(0, '#0a0a18'); // 더 깊은 우주색
                gradient.addColorStop(1, '#18182c');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, gameCanvasEl.width, gameCanvasEl.height);

                for (let i = 0; i < 200; i++) { 
                    const x = Math.random() * gameCanvasEl.width;
                    const y = Math.random() * gameCanvasEl.height;
                    const radius = Math.random() * 1.0 + 0.2; // 별 크기 미세 조정
                    const alpha = Math.random() * 0.5 + 0.1; // 별 밝기 다양화
                    ctx.fillStyle = `rgba(255, 255, 230, ${alpha})`;
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.save();
                ctx.globalAlpha = 0.03; // 성운 더 희미하게
                for(let i=0; i<2; i++){ // 성운 개수 줄임
                    ctx.fillStyle = `hsla(${190 + Math.random()*60}, 60%, 50%, 0.4)`;
                    ctx.beginPath();
                    ctx.arc(Math.random()*gameCanvasEl.width, Math.random()*gameCanvasEl.height, Math.random()*gameCanvasEl.width/4 + gameCanvasEl.width/5, 0, Math.PI*2);
                    ctx.fill();
                }
                ctx.restore();

            } else if (theme === 'forest') {
                const gradient = ctx.createLinearGradient(0, 0, 0, gameCanvasEl.height);
                gradient.addColorStop(0, '#101810'); 
                gradient.addColorStop(0.5, '#1d2a1d');
                gradient.addColorStop(1, '#283828'); 
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, gameCanvasEl.width, gameCanvasEl.height);

                const treeColors = ['#152515', '#1c301c', '#223822'];
                for (let layer = 0; layer < 3; layer++) {
                    for (let i = 0; i < 12 - layer * 3; i++) {
                        const treeX = (i * (gameCanvasEl.width / (11 - layer*3))) + (Math.random() - 0.5) * 40;
                        const treeHeight = gameCanvasEl.height * (0.3 + Math.random() * 0.4 + layer * 0.05);
                        const treeWidth = 30 + Math.random() * 25 + layer * 8;
                        ctx.fillStyle = treeColors[layer];
                        ctx.beginPath();
                        ctx.moveTo(treeX - treeWidth / 2, gameCanvasEl.height);
                        ctx.lineTo(treeX - treeWidth/3, gameCanvasEl.height - treeHeight * 0.8);
                        ctx.lineTo(treeX - treeWidth/1.5, gameCanvasEl.height - treeHeight * 0.7);
                        ctx.lineTo(treeX, gameCanvasEl.height - treeHeight);
                        ctx.lineTo(treeX + treeWidth/1.5, gameCanvasEl.height - treeHeight * 0.7);
                        ctx.lineTo(treeX + treeWidth/3, gameCanvasEl.height - treeHeight * 0.8);
                        ctx.lineTo(treeX + treeWidth / 2, gameCanvasEl.height);
                        ctx.closePath();
                        ctx.fill();
                    }
                }
                for(let i=0; i<gameCanvasEl.width*gameCanvasEl.height / 4000; i++){
                    ctx.fillStyle = `rgba(10,20,10,${0.08 + Math.random()*0.08})`;
                    ctx.fillRect(Math.random()*gameCanvasEl.width, gameCanvasEl.height - Math.random()*80, 3,3);
                }


            } else if (theme === 'lava') {
                const gradient = ctx.createRadialGradient(
                    gameCanvasEl.width / 2, gameCanvasEl.height * 1.3, gameCanvasEl.height * 0.05, 
                    gameCanvasEl.width / 2, gameCanvasEl.height, gameCanvasEl.height * 1.6
                );
                gradient.addColorStop(0, '#ff5000'); 
                gradient.addColorStop(0.25, '#c02000');
                gradient.addColorStop(0.7, '#500000');
                gradient.addColorStop(1, '#1a0000'); 
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, gameCanvasEl.width, gameCanvasEl.height);

                for(let i=0; i<20; i++){
                    ctx.beginPath();
                    ctx.moveTo(Math.random()*gameCanvasEl.width, Math.random()*gameCanvasEl.height);
                    const endX = Math.random()*gameCanvasEl.width;
                    const endY = Math.random()*gameCanvasEl.height;
                    ctx.quadraticCurveTo(Math.random()*gameCanvasEl.width, Math.random()*gameCanvasEl.height, endX, endY);
                    
                    ctx.shadowColor = '#ffae00';
                    ctx.shadowBlur = 8 + Math.random()*8;
                    ctx.strokeStyle = `rgba(255, ${80 + Math.random()*60}, 0, ${0.4 + Math.random()*0.2})`;
                    ctx.lineWidth = 0.5 + Math.random()*2.5;
                    ctx.stroke();
                    ctx.shadowBlur = 0; 

                    ctx.strokeStyle = `rgba(0,0,0,0.7)`;
                    ctx.lineWidth = 0.3 + Math.random()*0.8;
                    ctx.stroke();
                }
                // 희미한 화산 연기/실루엣
                 for(let i=0; i<3; i++){
                    ctx.fillStyle = `rgba(50,30,30,${0.1 + Math.random()*0.1})`;
                    ctx.beginPath();
                    ctx.moveTo(Math.random()*gameCanvasEl.width, gameCanvasEl.height);
                    ctx.lineTo(Math.random()*gameCanvasEl.width, gameCanvasEl.height * (0.3 + Math.random()*0.3));
                    ctx.lineTo(Math.random()*gameCanvasEl.width, gameCanvasEl.height);
                    ctx.closePath();
                    ctx.fill();
                }
            }
        }


        // 게임 초기화 및 시작
        function setupBattle() {
            const namesString = participantsInputEl.value.trim();
            if (!namesString) { alertUser("참가자 명단을 입력해주세요!"); return; }
            
            startScreenEl.style.display = 'none';
            gameScreenEl.style.display = 'block';
            winnerSectionEl.style.display = 'none'; 
            gameResultAnalysisSectionEl.style.display = 'none';


            const parsedNames = [];
            baseNameColors = {}; 
            colorIndex = 0; 

            namesString.split(',').forEach(part => {
                part = part.trim(); if (!part) return;
                if (part.includes('*')) {
                    const [name, countStr] = part.split('*');
                    const baseName = name.trim();
                    const count = parseInt(countStr, 10);
                    if (baseName && !isNaN(count) && count > 0) {
                        if (!baseNameColors[baseName]) { 
                            baseNameColors[baseName] = PREDEFINED_COLORS[colorIndex % PREDEFINED_COLORS.length];
                            colorIndex++;
                        }
                        for (let i = 0; i < count; i++) {
                            parsedNames.push(`${baseName}_${i + 1}`); 
                        }
                    } else { parsedNames.push(part); }
                } else { 
                    const baseName = part;
                     if (!baseNameColors[baseName]) {
                        baseNameColors[baseName] = PREDEFINED_COLORS[colorIndex % PREDEFINED_COLORS.length];
                        colorIndex++;
                    }
                    parsedNames.push(part); 
                }
            });
            if (parsedNames.length === 0 || (parsedNames.length === 1 && parsedNames[0] === "")) {
                 alertUser("유효한 참가자가 없습니다. 이름을 다시 입력해주세요."); 
                 startScreenEl.style.display = 'block';
                 gameScreenEl.style.display = 'none';
                 return;
            }
            gameOver = false; uniqueIdCounter = 0; particles = []; attackEffects = [];
            battleStatsLogInterval = 0; itemSpawnTimer = 0;
            gameStartTime = Date.now(); 

            if (selectedMapTheme === 'random') {
                const themes = ['default', 'forest', 'lava'];
                currentMapTheme = themes[Math.floor(Math.random() * themes.length)];
            } else {
                currentMapTheme = selectedMapTheme;
            }
            
            requestAnimationFrame(() => {
                initGameArena(); 
                allPlayers = parsedNames.map((name, index) => {
                    const baseName = name.split('_')[0];
                    return new Player(name, `p${index}`, baseNameColors[baseName] || `hsl(${Math.random() * 360}, 80%, 60%)`, selectedPerk);
                });
                allPlayers.forEach(player => {
                    if (player.perk === 'luck') {
                        const itemTypes = ['health', 'speedBoost', 'attackBoost'];
                        const randomItemType = itemTypes[Math.floor(Math.random() * itemTypes.length)];
                        player.applyItemEffect({type: randomItemType}); 
                        logBattleMessage(`🍀 ${player.name}이(가) 행운 특성으로 시작 아이템(${randomItemType})을 획득했습니다!`, 'log-item');
                    }
                });

                displayParticipantCards();
                gameStatsDisplayEl.innerHTML = ''; 
                battleLogEl.innerHTML = ''; 
                logBattleMessage(`⚔️ ${currentMapTheme === 'default' ? '기본' : currentMapTheme === 'forest' ? '숲' : '용암'} 아레나의 문이 열렸습니다! 전투 시작! ⚔️`, 'log-event');
                startButtonEl.disabled = true; participantsInputEl.disabled = true;
                if (allPlayers.length === 1) {
                    setTimeout(() => declareWinner(allPlayers[0]), 1000 / gameSpeedMultiplier);
                } else if (allPlayers.length > 1) {
                    lastFrameTime = performance.now(); 
                    setTimeout(startGameLoop, 1000 / gameSpeedMultiplier);
                }
            });
        }
        
        function displayParticipantCards() {
            participantsDisplayEl.innerHTML = '';
            allPlayers.forEach(player => {
                const card = document.createElement('div');
                card.classList.add('participant-card');
                card.id = `card-${player.id}`;
                
                const nameSpan = document.createElement('span');
                nameSpan.textContent = player.name;
                card.appendChild(nameSpan);

                const jobSpan = document.createElement('span');
                jobSpan.classList.add('job-display');
                jobSpan.textContent = `(${player.job})`; 
                card.appendChild(jobSpan);

                const hpBarContainer = document.createElement('div');
                hpBarContainer.classList.add('hp-bar-container');
                const hpBar = document.createElement('div');
                hpBar.classList.add('hp-bar');
                hpBarContainer.appendChild(hpBar);
                card.appendChild(hpBarContainer);
                player.element = card; 
                participantsDisplayEl.appendChild(card);
                player.updateCardHP(); 
            });
        }

        function initGameArena() {
            gameCanvasEl.width = gameCanvasEl.offsetWidth; 
            gameCanvasEl.height = gameCanvasEl.offsetHeight;
            
            const gridCols = Math.floor(gameCanvasEl.width / GRID_CELL_SIZE);
            const gridRows = Math.floor(gameCanvasEl.height / GRID_CELL_SIZE);
            if (gridRows <= 0 || gridCols <= 0) {
                grid = [[0]]; obstacles = []; items = []; return; 
            }
            grid = Array(gridRows).fill(null).map(() => Array(gridCols).fill(0));
            obstacles = [];
            
            let numWalls = NUM_OBSTACLES_BASE;
            let numPitsOrLava = NUM_PITS_BASE;
            let numBushes = 0;

            if (currentMapTheme === 'forest') {
                numWalls = Math.floor(NUM_OBSTACLES_BASE * 0.6);
                numBushes = NUM_OBSTACLES_BASE - numWalls + 2; 
            } else if (currentMapTheme === 'lava') {
                 numPitsOrLava = NUM_PITS_BASE + 1; 
                 numWalls = Math.floor(NUM_OBSTACLES_BASE * 0.8);
            }

            for (let i = 0; i < numWalls + numBushes; i++) {
                const isBush = currentMapTheme === 'forest' && i >= numWalls;
                const obsType = isBush ? 'bush' : 'wall';
                let sizeW, sizeH;
                if (obsType === 'wall' && Math.random() < 0.4) { 
                     if (Math.random() < 0.5) { 
                        sizeW = Math.random() * (OBSTACLE_MAX_SIZE * OBSTACLE_MAX_LENGTH_FACTOR - OBSTACLE_MAX_SIZE) + OBSTACLE_MAX_SIZE;
                        sizeH = Math.random() * (OBSTACLE_MAX_SIZE * 0.7 - OBSTACLE_MIN_SIZE * 0.5) + OBSTACLE_MIN_SIZE * 0.5;
                    } else { 
                        sizeW = Math.random() * (OBSTACLE_MAX_SIZE * 0.7 - OBSTACLE_MIN_SIZE * 0.5) + OBSTACLE_MIN_SIZE * 0.5;
                        sizeH = Math.random() * (OBSTACLE_MAX_SIZE * OBSTACLE_MAX_LENGTH_FACTOR - OBSTACLE_MAX_SIZE) + OBSTACLE_MAX_SIZE;
                    }
                } else { 
                    sizeW = Math.random() * (OBSTACLE_MAX_SIZE - OBSTACLE_MIN_SIZE) + OBSTACLE_MIN_SIZE;
                    sizeH = Math.random() * (OBSTACLE_MAX_SIZE - OBSTACLE_MIN_SIZE) + OBSTACLE_MIN_SIZE;
                }
                sizeW = Math.max(OBSTACLE_MIN_SIZE * 0.4, Math.min(sizeW, OBSTACLE_MAX_SIZE * OBSTACLE_MAX_LENGTH_FACTOR * 1.2));
                sizeH = Math.max(OBSTACLE_MIN_SIZE * 0.4, Math.min(sizeH, OBSTACLE_MAX_SIZE * OBSTACLE_MAX_LENGTH_FACTOR * 1.2));


                const obsX = Math.random() * (gameCanvasEl.width - sizeW);
                const obsY = Math.random() * (gameCanvasEl.height - sizeH);
                obstacles.push(new Obstacle(obsX, obsY, sizeW, sizeH, obsType, currentMapTheme));
                const startCol = Math.max(0, Math.floor(obsX / GRID_CELL_SIZE));
                const endCol = Math.min(gridCols - 1, Math.floor((obsX + sizeW) / GRID_CELL_SIZE));
                const startRow = Math.max(0, Math.floor(obsY / GRID_CELL_SIZE));
                const endRow = Math.min(gridRows - 1, Math.floor((obsY + sizeH) / GRID_CELL_SIZE));
                for (let r = startRow; r <= endRow; r++) {
                    for (let c = startCol; c <= endCol; c++) {
                        if (grid[r] && grid[r][c] !== undefined) grid[r][c] = 1; 
                    }
                }
            }
            for (let i = 0; i < numPitsOrLava; i++) {
                const obsType = currentMapTheme === 'lava' ? 'lava_pool' : 'pit';
                const pitRadius = (Math.random() * (OBSTACLE_MAX_SIZE - OBSTACLE_MIN_SIZE) + OBSTACLE_MIN_SIZE) / 2;
                const obsX = Math.random() * (gameCanvasEl.width - pitRadius*2);
                const obsY = Math.random() * (gameCanvasEl.height - pitRadius*2);
                obstacles.push(new Obstacle(obsX, obsY, pitRadius*2, pitRadius*2, obsType, currentMapTheme));
            }
            for (let i = 0; i < NUM_SPECIAL_TERRAIN_BASE; i++) {
                const type = Math.random() < 0.5 ? 'swamp' : 'speed_pad';
                const size = Math.random() * 20 + 40; 
                const obsX = Math.random() * (gameCanvasEl.width - size);
                const obsY = Math.random() * (gameCanvasEl.height - size);
                obstacles.push(new Obstacle(obsX, obsY, size, size, type, currentMapTheme));
            }


            items = []; 
            spawnInitialItems();
        }

        function spawnInitialItems() {
            for (let i = 0; i < Math.floor(NUM_ITEMS_MAX / 2) ; i++) { 
                spawnNewItem();
            }
        }

        function spawnNewItem() {
            if (items.length >= NUM_ITEMS_MAX) return; 
            const itemTypes = ['health', 'speedBoost', 'attackBoost'];
            const type = itemTypes[Math.floor(Math.random() * itemTypes.length)];
            let itemX, itemY, itemGridX, itemGridY;
            let attempts = 0; const maxAttempts = 20; 
            do {
                itemX = Math.random() * (gameCanvasEl.width - ITEM_RADIUS * 2) + ITEM_RADIUS;
                itemY = Math.random() * (gameCanvasEl.height - ITEM_RADIUS * 2) + ITEM_RADIUS;
                itemGridX = Math.floor(itemX / GRID_CELL_SIZE);
                itemGridY = Math.floor(itemY / GRID_CELL_SIZE);
                attempts++;
            } while (
                attempts < maxAttempts &&
                (itemGridY < 0 || itemGridY >= grid.length || 
                 itemGridX < 0 || !grid[itemGridY] || itemGridX >= grid[itemGridY].length || 
                 grid[itemGridY][itemGridX] === 1) 
            );
            if (attempts < maxAttempts) { items.push(new Item(itemX, itemY, type)); }
        }


        function startGameLoop() {
            if (gameOver) return; 
            gameLoopId = requestAnimationFrame(gameLoop);
        }

        function gameLoop(currentTime) { 
            if (gameOver) { cancelAnimationFrame(gameLoopId); return; }

            const deltaTime = (currentTime - lastFrameTime) / (1000 / 60) * gameSpeedMultiplier; 
            lastFrameTime = currentTime;


            ctx.save(); 
            drawBackground(currentMapTheme); 


            const alivePlayers = allPlayers.filter(p => p.isAlive);
            
            if (alivePlayers.length >= 2 && alivePlayers.length <= 3 && allPlayers.length > 3) { 
                if (!isClutchCamActive) {
                    isClutchCamActive = true;
                }
                let centerX = 0;
                let centerY = 0;
                alivePlayers.forEach(p => { centerX += p.x; centerY += p.y; });
                centerX /= alivePlayers.length;
                centerY /= alivePlayers.length;

                const scale = 1.5; 
                const translateX = gameCanvasEl.width / 2 - centerX * scale;
                const translateY = gameCanvasEl.height / 2 - centerY * scale;
                
                ctx.translate(translateX, translateY);
                ctx.scale(scale, scale);

            } else {
                if (isClutchCamActive) {
                    isClutchCamActive = false;
                }
            }
            
            items.forEach(i => { i.update(deltaTime); i.draw(); }); 
            obstacles.forEach(o => o.draw()); 
            
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].update(deltaTime); particles[i].draw(); 
                if (particles[i].life <= 0) particles.splice(i, 1);
            }
            
            alivePlayers.forEach(player => { 
                player.update(allPlayers, grid, items, deltaTime); player.draw(); 
            });

            for (let i = attackEffects.length - 1; i >= 0; i--) {
                attackEffects[i].update(deltaTime); attackEffects[i].draw(); 
                if (attackEffects[i].currentFrame >= attackEffects[i].duration && 
                    (!attackEffects[i].type || (attackEffects[i].type !== 'wave' && attackEffects[i].type !== 'static_aoe' && attackEffects[i].type !== 'aura'))) { 
                    attackEffects.splice(i, 1);
                } else if ((attackEffects[i].type === 'wave' || attackEffects[i].type === 'static_aoe' || attackEffects[i].type === 'aura') && attackEffects[i].currentFrame >= attackEffects[i].duration) {
                     attackEffects.splice(i, 1);
                }
            }
            
            ctx.restore(); 

            battleStatsLogInterval += deltaTime;
            if (battleStatsLogInterval >= (60 * 7) && alivePlayers.length > 1) { 
                updateBattleStatsLog(alivePlayers);
                battleStatsLogInterval = 0;
            }

            itemSpawnTimer += deltaTime;
            if (itemSpawnTimer >= ITEM_SPAWN_INTERVAL_BASE) {
                spawnNewItem();
                itemSpawnTimer = 0;
            }

            if (!gameOver) { 
                if (alivePlayers.length > 0) {
                    const firstPlayerBaseName = alivePlayers[0].baseName;
                    const allSameBaseName = alivePlayers.every(p => p.baseName === firstPlayerBaseName);
                    const initialPlayerBaseNames = new Set(allPlayers.map(p => p.baseName));
                    if (allSameBaseName && initialPlayerBaseNames.size > 1 && alivePlayers.length < allPlayers.length) { 
                        gameOver = true;
                        declareWinner(alivePlayers[0]); 
                    }
                }

                if (alivePlayers.length <= 1 && allPlayers.length > 1 && !gameOver) { 
                    gameOver = true; 
                    if (alivePlayers.length === 1) {
                        declareWinner(alivePlayers[0]);
                    } else { 
                        logBattleMessage('모든 참가자가 동시에 탈락했습니다! 아쉬운 무승부입니다.', 'log-event');
                        resetGameComponents();
                        displayGameAnalysis(); 
                    }
                }
            }


            if (!gameOver) { gameLoopId = requestAnimationFrame(gameLoop); }
        }
        
        function updateBattleStatsLog(alivePlayers) {
            if (gameOver || alivePlayers.length <= 1) return;
            let message = `현재 ${alivePlayers.length}명의 용사가 생존하여 치열한 전투를 벌이고 있습니다.`;
            const killLeaders = alivePlayers.filter(p => p.kills > 0).sort((a, b) => b.kills - a.kills);
            if (killLeaders.length > 0 && killLeaders[0].kills > 0) {
                 message += ` 현재 ${killLeaders[0].name} 선수가 ${killLeaders[0].kills}킬로 선두를 질주합니다!`;
            }
            logBattleMessage(message, 'log-stats');
        }


        function declareWinner(winner) {
            if (winnerSectionEl.style.display === 'block') return; 
            gameOver = true; cancelAnimationFrame(gameLoopId); 
            
            const winnerDisplayName = winner.baseName; 
            logBattleMessage(`👑 ${winnerDisplayName} 선수가 최후의 1인으로 등극했습니다! 대단합니다! 👑`, 'log-event');
            winnerNameEl.textContent = winnerDisplayName;
            winnerSectionEl.style.display = 'block';
            gameScreenEl.style.display = 'none'; 
            
            resetGameComponents(); 
            displayGameAnalysis(); 
        }

        function displayGameAnalysis() { 
            gameResultAnalysisSectionEl.style.display = 'block';
            detailedPlayerStatsEl.innerHTML = '<h4>📊 상세 플레이어 통계 📊</h4>';
            
            if (selectedSortCriterion === 'survivalTime') {
                allPlayers.sort((a,b) => b.survivalTime - a.survivalTime || b.kills - a.kills || b.damageDealt - a.damageDealt); 
            } else if (selectedSortCriterion === 'damageDealt') {
                allPlayers.sort((a,b) => b.damageDealt - a.damageDealt || b.survivalTime - a.survivalTime || b.kills - a.kills);
            } else if (selectedSortCriterion === 'kills') {
                allPlayers.sort((a,b) => b.kills - a.kills || b.survivalTime - a.survivalTime || b.damageDealt - a.damageDealt);
            }


            allPlayers.forEach((p, index) => { 
                const survivalMinutes = Math.floor(p.survivalTime / (60 * 60)); 
                const survivalSeconds = Math.floor((p.survivalTime / 60) % 60);
                const timeString = `${survivalMinutes}분 ${survivalSeconds}초`;

                let perkText = "없음";
                if (p.perk === 'toughness') perkText = "강인함";
                else if (p.perk === 'swiftness') perkText = "신속함";
                else if (p.perk === 'luck') perkText = "행운";

                const entry = document.createElement('div');
                entry.classList.add('player-stat-entry');
                entry.innerHTML = `
                    <p><span class="player-rank">${index + 1}.</span> <strong>${p.name}</strong> (${p.job}) - ${p.isAlive ? "생존" : "탈락"}</p>
                    <p>선택 특성: ${perkText}</p>
                    <p>생존 시간: ${timeString}</p>
                    <p>킬 수: ${p.kills}</p>
                    <p>준 피해량: ${p.damageDealt.toFixed(0)}</p>
                    <p>아이템 사용: ${p.itemsUsed}개</p>
                    <p>궁극기 사용: ${p.ultimatesUsed}회</p>
                `;
                detailedPlayerStatsEl.appendChild(entry);
            });

            if (winnerSectionEl.style.display === 'block') {
                 displayGameMVPStats();
            }
        }
        
        function displayGameMVPStats() { 
            gameStatsDisplayEl.innerHTML = '<h4>🏆 MVP 통계 🏆</h4>';
            let maxKills = -1; 
            let mvpByKills = '-';
            allPlayers.forEach(p => {
                if (p.kills > maxKills) {
                    maxKills = p.kills;
                    mvpByKills = p.name;
                }
            });
            if (maxKills > 0) gameStatsDisplayEl.innerHTML += `<p>최다 킬: ${mvpByKills} (${maxKills}킬)</p>`;
            else gameStatsDisplayEl.innerHTML += `<p>최다 킬: 해당 없음</p>`;


            let maxDamage = 0;
            let mvpByDamage = '-';
            allPlayers.forEach(p => {
                if (p.damageDealt > maxDamage) {
                    maxDamage = p.damageDealt;
                    mvpByDamage = p.name;
                }
            });
             if (maxDamage > 0) gameStatsDisplayEl.innerHTML += `<p>최고 데미지: ${mvpByDamage} (${maxDamage.toFixed(0)} 데미지)</p>`;
             else gameStatsDisplayEl.innerHTML += `<p>최고 데미지: 해당 없음</p>`;
        }
        
        function resetGameComponents() {
            startButtonEl.disabled = false;
            participantsInputEl.disabled = false;
            gameCanvasEl.style.transform = ''; 
            isClutchCamActive = false;
        }

        function logBattleMessage(message, type = '') { 
            const p = document.createElement('p');
            p.textContent = message;
            if (type) p.classList.add(type);
            battleLogEl.appendChild(p);
            if (battleLogEl.childNodes.length > 50) {
                battleLogEl.removeChild(battleLogEl.firstChild);
            }
            battleLogEl.scrollTop = battleLogEl.scrollHeight; 
        }

        function resetGame() {
            gameOver = true; cancelAnimationFrame(gameLoopId); 
            allPlayers = []; items = []; obstacles = []; particles = []; /* backgroundParticles는 정적이므로 유지 */ attackEffects = [];
            grid = []; battleStatsLogInterval = 0; itemSpawnTimer = 0; gameStartTime = 0;
            ctx.clearRect(0, 0, gameCanvasEl.width, gameCanvasEl.height);
            participantsDisplayEl.innerHTML = ''; battleLogEl.innerHTML = '';
            winnerSectionEl.style.display = 'none';
            gameResultAnalysisSectionEl.style.display = 'none'; 
            winnerNameEl.textContent = ''; 
            gameStatsDisplayEl.innerHTML = ''; 
            detailedPlayerStatsEl.innerHTML = '';
            participantsInputEl.value = ''; 
            
            startScreenEl.style.display = 'block'; 
            gameScreenEl.style.display = 'none'; 

            resetGameComponents();
        }
        
        function alertUser(message) {
            const existingModal = document.getElementById('customAlertModal');
            if (existingModal) existingModal.remove();
            const modal = document.createElement('div');
            modal.id = 'customAlertModal';
            modal.innerHTML = `<p>${message}</p><button id="customAlertOk">확인</button>`;
            document.body.appendChild(modal);
            document.getElementById('customAlertOk').addEventListener('click', () => modal.remove());
        }

        mapSelectionButtons.forEach(button => {
            button.addEventListener('click', () => {
                mapSelectionButtons.forEach(btn => btn.classList.remove('selected'));
                button.classList.add('selected');
                selectedMapTheme = button.dataset.map;
            });
        });
        perkSelectionButtons.forEach(button => {
            button.addEventListener('click', () => {
                perkSelectionButtons.forEach(btn => btn.classList.remove('selected'));
                button.classList.add('selected');
                selectedPerk = button.dataset.perk;
            });
        });
        sortCriteriaButtons.forEach(button => {
            button.addEventListener('click', () => {
                sortCriteriaButtons.forEach(btn => btn.classList.remove('selected'));
                button.classList.add('selected');
                selectedSortCriterion = button.dataset.sort;
                if (allPlayers.length > 0) { 
                    displayGameAnalysis();
                }
            });
        });


        function setActiveSpeedButton(speed) {
            [speed1xButton, speed1_5xButton, speed2xButton].forEach(btn => btn.classList.remove('active'));
            if (speed === 1) speed1xButton.classList.add('active');
            else if (speed === 1.5) speed1_5xButton.classList.add('active');
            else if (speed === 2) speed2xButton.classList.add('active');
        }
        speed1xButton.addEventListener('click', () => { gameSpeedMultiplier = 1; setActiveSpeedButton(1); });
        speed1_5xButton.addEventListener('click', () => { gameSpeedMultiplier = 1.5; setActiveSpeedButton(1.5); });
        speed2xButton.addEventListener('click', () => { gameSpeedMultiplier = 2; setActiveSpeedButton(2); });


        startButtonEl.addEventListener('click', setupBattle);
        resetButtonEl.addEventListener('click', resetGame);
        resetButtonFromAnalysisEl.addEventListener('click', resetGame); 
        
        window.addEventListener('resize', () => {
            if (gameScreenEl.style.display === 'block' && gameCanvasEl.offsetParent !== null) { 
                const oldWidth = gameCanvasEl.width;
                const oldHeight = gameCanvasEl.height;
                gameCanvasEl.width = gameCanvasEl.offsetWidth;
                gameCanvasEl.height = gameCanvasEl.offsetHeight;
                
                // initBackgroundParticles(currentMapTheme, gameCanvasEl.width, gameCanvasEl.height); // 정적 배경은 다시 그리기만 하면 됨

                if (oldWidth > 0 && oldHeight > 0 && allPlayers.length > 0) { 
                    const scaleX = gameCanvasEl.width / oldWidth;
                    const scaleY = gameCanvasEl.height / oldHeight;
                    const newGridCols = Math.floor(gameCanvasEl.width / GRID_CELL_SIZE);
                    const newGridRows = Math.floor(gameCanvasEl.height / GRID_CELL_SIZE);
                    if (newGridRows > 0 && newGridCols > 0) {
                        grid = Array(newGridRows).fill(null).map(() => Array(newGridCols).fill(0));
                        obstacles.forEach(o => { 
                            o.x *= scaleX; o.y *= scaleY; o.width *= scaleX; o.height *= scaleY;
                            o.x = Math.max(0, Math.min(o.x, gameCanvasEl.width - o.width));
                            o.y = Math.max(0, Math.min(o.y, gameCanvasEl.height - o.height));
                            if (o.isRound) o.radius = Math.min(o.width, o.height) / 2;

                            const startCol = Math.max(0, Math.floor(o.x / GRID_CELL_SIZE));
                            const endCol = Math.min(newGridCols - 1, Math.floor((o.x + o.width) / GRID_CELL_SIZE));
                            const startRow = Math.max(0, Math.floor(o.y / GRID_CELL_SIZE));
                            const endRow = Math.min(newGridRows - 1, Math.floor((o.y + o.height) / GRID_CELL_SIZE));
                            for (let r = startRow; r <= endRow; r++) {
                                for (let c = startCol; c <= endCol; c++) {
                                    if (grid[r] && grid[r][c] !== undefined && o.type !== 'pit' && o.type !== 'swamp' && o.type !== 'speed_pad' && o.type !== 'lava_pool') grid[r][c] = 1;
                                }
                            }
                        });
                    } else { grid = [[0]]; }
                    items.forEach(i => {
                        i.x *= scaleX; i.y *= scaleY;
                        i.x = Math.max(i.radius, Math.min(i.x, gameCanvasEl.width - i.radius));
                        i.y = Math.max(i.radius, Math.min(i.y, gameCanvasEl.height - i.radius));
                    });
                     allPlayers.forEach(p => {
                        p.x *= scaleX; p.y *= scaleY;
                        p.x = Math.max(p.radius, Math.min(p.x, gameCanvasEl.width - p.radius));
                        p.y = Math.max(p.radius, Math.min(p.y, gameCanvasEl.height - p.radius));
                        p.path = []; 
                    });
                } else if (allPlayers.length === 0 && currentMapTheme !== 'random') { 
                     initGameArena(); // 게임 시작 전 리사이즈 시에도 아레나 초기화 (배경 포함)
                }
                // 리사이즈 후에도 현재 게임 상태를 다시 그려줌
                if (!gameOver) { 
                    drawBackground(currentMapTheme); // 배경 다시 그리기
                    // backgroundParticles.forEach(p => p.draw(ctx)); // 정적 배경에서는 불필요할 수 있음
                    items.forEach(i => i.draw()); 
                    obstacles.forEach(o => o.draw()); 
                    allPlayers.filter(p => p.isAlive).forEach(player => player.draw());
                    attackEffects.forEach(ae => ae.draw());
                } else if (winnerSectionEl.style.display === 'block' || gameResultAnalysisSectionEl.style.display === 'block') { 
                    drawBackground(currentMapTheme); // 배경 다시 그리기
                    obstacles.forEach(o => o.draw());
                }
            }
        });
    </script>
</body>
</html>
