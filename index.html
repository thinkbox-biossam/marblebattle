<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>마블배틀로얄</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        /* 기본 스타일 초기화 */
        body, h1, h2, p, button, textarea, label, h3, h4, div {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Noto Sans KR', sans-serif;
        }

        body {
            background-color: #1a1a2e; /* 어두운 남색 배경 */
            color: #e0e0e0; /* 밝은 회색 텍스트 */
            display: flex;
            flex-direction: column; /* 컨텐츠를 세로로 정렬 */
            justify-content: center;
            align-items: center; 
            min-height: 100vh;
            padding: 20px;
            overflow-y: auto; 
        }

        .container {
            background-color: #232334; 
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
            width: 100%;
            max-width: 800px; 
            text-align: center;
        }
        
        /* 시작 화면 스타일 */
        #startScreen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding-top: 50px; 
        }
        #startScreen h1 {
            font-size: 3em;
            margin-bottom: 40px;
            text-shadow: 0 0 10px #f03a78, 0 0 20px #f03a78;
        }
        #startScreen .start-button-group button {
            font-size: 1.2em;
            padding: 15px 30px;
            margin: 10px;
            width: 200px;
        }


        h1 {
            color: #f03a78; 
            margin-bottom: 25px;
            font-size: 2.4em; 
            font-weight: 700;
            letter-spacing: 1px;
        }

        h2 {
            color: #7aa5ff; 
            margin-bottom: 15px;
            font-size: 1.6em;
        }
        h3 {
            color: #9fa8da; 
            margin-top: 15px;
            margin-bottom: 8px;
            font-size: 1.1em;
            text-align: left;
        }

        /* 입력 섹션 */
        .input-section {
            background-color: #2a2a3e;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 25px;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.2);
        }

        .input-section label {
            display: block;
            margin-bottom: 8px;
            color: #c0c0ff;
            font-size: 0.95em;
            text-align: left;
        }

        #participantsInput {
            width: 100%;
            padding: 12px;
            border-radius: 8px;
            border: 1px solid #4a4a5e;
            background-color: #3a3a4e;
            color: #e0e0e0;
            font-size: 1em;
            min-height: 80px;
            resize: vertical;
        }

        #participantsInput::placeholder {
            color: #888dac;
        }

        /* 버튼 스타일 */
        button {
            background-color: #f03a78;
            color: white;
            padding: 10px 20px; 
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em; 
            font-weight: 500;
            margin-top: 15px;
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
            box-shadow: 0 4px 8px rgba(240, 58, 120, 0.3);
        }
       
        button:hover {
            background-color: #d01a58;
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(240, 58, 120, 0.4);
        }

        button:disabled {
            background-color: #555;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }

        #resetButton {
            background-color: #7aa5ff;
            box-shadow: 0 4px 8px rgba(122, 165, 255, 0.3);
        }
        #resetButton:hover {
            background-color: #5c8ae6;
            box-shadow: 0 6px 12px rgba(122, 165, 255, 0.4);
        }

        /* 배속 버튼 그룹 */
        .speed-controls {
            margin-top: 10px;
            margin-bottom: 20px;
        }
        .speed-controls button {
            background-color: #4a4a5e;
            padding: 8px 15px;
            font-size: 0.9em;
            margin-left: 5px;
            margin-right: 5px;
        }
        .speed-controls button.active {
            background-color: #7aa5ff;
            box-shadow: 0 0 10px rgba(122, 165, 255, 0.5);
            transform: translateY(-1px); 
        }


        /* 아레나 섹션 */
        .arena-section {
            background-color: #2a2a3e;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 25px;
            position: relative; 
            overflow: hidden; 
        }
        
        #gameCanvas {
            width: 100%;
            height: 400px; 
            background: linear-gradient(135deg, #1e1e2d 0%, #2b2b40 100%); 
            border-radius: 8px;
            border: 1px solid #4a4a5e;
            margin-bottom: 15px;
            cursor: default; 
            transition: transform 0.5s ease-out; 
        }

        #participantsDisplay {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            margin-bottom: 15px;
        }

        .participant-card {
            background-color: #3a3a4e;
            color: #c0c0ff;
            border: 2px solid #5a5aff;
            padding: 8px 12px; 
            border-radius: 6px;
            min-width: 90px; 
            text-align: center;
            font-size: 0.9em; 
            transition: all 0.3s ease-in-out;
            box-shadow: 0 0 8px rgba(90, 90, 255, 0.3);
        }
        .participant-card .job-display { 
            font-size: 0.8em;
            color: #aaa;
            margin-top: 3px;
        }
        
        .participant-card .hp-bar-container {
            width: 100%; height: 8px; background-color: #2c2c3a; 
            border-radius: 4px; margin-top: 5px; overflow: hidden;
            border: 1px solid #1e1e2d; 
        }
        .participant-card .hp-bar {
            height: 100%; width: 100%; background-color: #4caf50;
            border-radius: 4px; transition: width 0.2s ease;
        }
         .participant-card.low-hp .hp-bar { background-color: #f44336; }
        .participant-card.eliminated {
            opacity: 0.4; background-color: #444; border-color: #666;
            transform: scale(0.95); box-shadow: none;
        }
        .participant-card.eliminated .hp-bar { width: 0% !important; }
        .participant-card.winner {
            background-color: #ffd700; color: #333; border-color: #ffc107;
            transform: scale(1.1); font-weight: 700; animation: pulseCard 1.5s infinite;
        }

        @keyframes pulseCard {
            0% { transform: scale(1.05); box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);}
            50% { transform: scale(1.15); box-shadow: 0 0 25px rgba(255, 215, 0, 0.7);}
            100% { transform: scale(1.05); box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);}
        }

        /* 배틀 로그 */
        #battleLogContainer{
            margin-top: 15px;
            padding: 10px;
            background-color: #333343;
            border-radius: 8px;
        }
        #battleLog {
            font-size: 0.95em;
            color: #ffc107; 
            min-height: 40px; 
            font-weight: 500;
            text-align: left;
            max-height: 120px; 
            overflow-y: auto;
            padding: 8px;
            background-color: #2c2c3a; 
            border-radius: 5px;
        }
      
        #battleLog p {
             animation: fadeInLog 0.3s ease;
             margin-bottom: 4px;
        }
        .log-stats { 
            color: #66bfff; 
            font-style: italic;
        }
        .log-event { 
             color: #ffeb3b; 
        }
        .log-item { 
            color: #90ee90; 
        }
        .log-ultimate { 
            color: #ff69b4; 
            font-weight: bold;
        }
        .log-pit { 
            color: #a8836b;
        }


        @keyframes fadeInLog {
            from { opacity: 0; transform: translateX(-10px); }
            to { opacity: 1; transform: translateX(0); }
        }

        /* 우승자 섹션 */
        .winner-section {
            background-color: #2a2a3e; padding: 25px; border-radius: 10px;
            margin-top: 25px; border: 2px solid #f03a78;
            box-shadow: 0 0 20px rgba(240, 58, 120, 0.4);
        }
        #winnerName {
            font-size: 2.5em; color: #f03a78; font-weight: 700;
            margin-bottom: 10px; animation: winnerPop 0.5s ease-out;
        }
       
        #gameStatsDisplay { 
            margin-top: 20px;
            padding: 15px;
            background-color: #333343;
            border-radius: 8px;
            text-align: left;
            font-size: 0.9em;
        }
        #gameStatsDisplay h4 {
            color: #7aa5ff;
            margin-bottom: 10px;
        }
        #gameStatsDisplay p {
            margin-bottom: 5px;
            color: #e0e0e0;
        }
        
        @keyframes winnerPop {
            0% { transform: scale(0.5); opacity: 0;}
            80% { transform: scale(1.1); opacity: 1;}
            100% { transform: scale(1); opacity: 1;}
        }

        /* 모달 스타일 (규칙 보기, 맵 선택) */
        .modal {
            display: none; 
            position: fixed; 
            z-index: 1001; 
            left: 0;
            top: 0;
            width: 100%; 
            height: 100%; 
            overflow: auto; 
            background-color: rgba(0,0,0,0.6); 
            padding-top: 60px;
        }
        .modal-content {
            background-color: #2a2a3e;
            margin: 5% auto;
            padding: 25px;
            border: 1px solid #888;
            width: 80%;
            max-width: 600px;
            border-radius: 10px;
            color: #e0e0e0;
            text-align: left;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
        }
        .modal-content h2 { color: #7aa5ff; margin-bottom: 20px; text-align: center;}
        .modal-content h4 { color: #c0c0ff; margin-top: 15px; margin-bottom: 5px;}
        .modal-content p, .modal-content li { margin-bottom: 8px; line-height: 1.6; }
        .modal-content ul { padding-left: 20px; }
        .close-button {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
        }
        .close-button:hover,
        .close-button:focus {
            color: #f03a78;
            text-decoration: none;
            cursor: pointer;
        }
        .map-selection button {
            display: block;
            width: 80%;
            margin: 10px auto;
            background-color: #4a4a5e;
        }
        .map-selection button:hover {
            background-color: #5a5aff;
        }


        /* 커스텀 알림창 */
        #customAlertModal {
            position: fixed; left: 50%; top: 50%; transform: translate(-50%, -50%);
            background-color: #3a3a4e; color: white; padding: 25px;
            border: 1px solid #f03a78; border-radius: 10px; z-index: 1002; 
            box-shadow: 0 5px 15px rgba(0,0,0,0.5); width: 90%; max-width: 350px;
            text-align: center;
        }
        #customAlertModal p { margin: 0 0 15px 0; font-size: 1.1em; line-height: 1.6; }
        #customAlertModal button { background-color: #f03a78; padding: 10px 20px; }
        #customAlertModal button:hover { background-color: #d01a58; }

        /* 모바일 반응형 */
        @media (max-width: 600px) {
            body { padding: 10px; }
            .container { padding: 15px; max-width: 100%;}
            h1 { font-size: 1.8em; margin-bottom: 20px; }
            #startScreen h1 { font-size: 2.5em; }
            #startScreen .start-button-group button { font-size: 1em; padding: 12px 20px; width: 180px;}

            h2 { font-size: 1.4em; }
            h3 { font-size: 1em; }
            #participantsInput { min-height: 70px; padding: 10px; }
            button, button.secondary { padding: 10px 18px; font-size: 1em; margin-left: 5px; }
            .participant-card { padding: 6px 10px; font-size: 0.8em; min-width: 70px;}
            #winnerName { font-size: 2em; }
            #gameCanvas { height: 300px; }
            #battleLog { max-height: 80px; font-size: 0.9em;}
            .modal-content { width: 90%; padding: 20px;}
        }
    </style>
</head>
<body>
    <div id="startScreen" class="container">
        <h1>마블배틀로얄</h1>
        <div class="start-button-group">
            <button id="startGameBtn">게임 시작</button>
            <button id="selectMapBtn">맵 선택</button>
            <button id="showRulesBtn">규칙 보기</button>
        </div>
    </div>

    <div id="gameContainer" class="container" style="display:none;">
        <h1>마블배틀로얄</h1>
        <div class="input-section">
            <label for="participantsInput">참가자 명단 (예: 아이언맨, 캡틴*3, 토르):</label>
            <textarea id="participantsInput" rows="4" placeholder="아이언맨, 캡틴 아메리카*2, 토르, 헐크"></textarea>
            <button id="startButton">배틀 시작!</button>
        </div>
        
        <div class="speed-controls" style="display:none;">
            <h3>게임 속도:</h3>
            <button id="speed1x" class="active">1x</button>
            <button id="speed2x">2x</button>
            <button id="speed4x">4x</button>
        </div>

        <div id="arena" class="arena-section" style="display:none;">
            <h2>배틀 아레나</h2>
            <canvas id="gameCanvas"></canvas>
            <div id="participantsDisplay"></div>
            
            <div id="battleLogContainer">
                 <h3>실시간 배틀 로그:</h3>
                 <div id="battleLog"></div>
            </div>
        </div>

        <div id="winnerSection" class="winner-section" style="display:none;">
            <h2>최종 우승자!</h2>
            <p id="winnerName"></p>
            <div id="gameStatsDisplay"></div> 
            <button id="resetButton">다시 하기</button>
        </div>
    </div>

    <div id="rulesModal" class="modal">
        <div class="modal-content">
            <span class="close-button" id="closeRulesModal">&times;</span>
            <h2>게임 규칙</h2>
            <h4>가. 게임 목표</h4>
            <p>최후의 1인(또는 1팀)이 될 때까지 다른 모든 플레이어를 탈락시키는 것이 목표입니다.</p>
            <h4>나. 플레이어 기본 규칙</h4>
            <ul>
                <li>각 플레이어는 고유한 직업(돌격자, 버서커, 궁수, 마법사)과 그에 따른 기본 능력치, 필살기를 가집니다.</li>
                <li>플레이어는 이동, 기본 공격, 필살기 사용이 가능합니다.</li>
                <li>HP가 0이 되면 탈락합니다.</li>
            </ul>
            <h4>다. 아이템 규칙</h4>
            <ul>
                <li>맵에 주기적으로 다양한 효과(체력 회복, 속도 증가, 공격력 증가)를 가진 아이템이 생성됩니다.</li>
                <li>아이템은 먼저 획득한 플레이어에게 즉시 효과가 적용됩니다.</li>
                <li>아이템 효과는 일정 시간 동안 지속됩니다.</li>
            </ul>
            <h4>라. 장애물 및 지형 규칙</h4>
            <ul>
                <li><b>벽</b>: 통과할 수 없는 장애물입니다.</li>
                <li><b>구덩이</b>: 빠지면 이동 속도가 감소하고 지속적인 피해를 입습니다.</li>
                <li><b>가속 발판</b>: 밟으면 짧은 시간 동안 이동 속도가 증가합니다.</li>
                <li><b>은신 수풀</b>: 들어가면 다른 플레이어에게 잠시 보이지 않게 됩니다.</li>
            </ul>
             <h4>마. 게임 진행 규칙</h4>
            <ul>
                <li><b>시작</b>: 모든 플레이어는 랜덤한 위치에서 시작합니다.</li>
                <li><b>전투</b>: 자유롭게 다른 플레이어를 공격할 수 있습니다. (같은 베이스 이름을 가진 증폭된 플레이어끼리는 서로 공격하지 않습니다.)</li>
                <li><b>클러치캠</b>: 생존자가 2~3명으로 줄어들면 시점이 자동으로 해당 플레이어들에게 집중됩니다.</li>
                <li><b>게임 종료</b>: 최후의 1인(또는 1팀)이 남으면 게임이 종료되고, 해당 플레이어(팀)가 승리합니다.</li>
                <li><b>통계</b>: 게임 종료 후 개인별 주요 통계(킬 수, 데미지, 아이템 사용 등)가 제공됩니다.</li>
            </ul>
        </div>
    </div>

    <div id="mapSelectModal" class="modal">
        <div class="modal-content">
            <span class="close-button" id="closeMapModal">&times;</span>
            <h2>맵 선택</h2>
            <div class="map-selection">
                <button data-map="default">기본 맵 (랜덤 장애물)</button>
                <button data-map="narrow">좁은 길목 맵</button>
                <button data-map="wide">넓은 광장 맵</button>
            </div>
        </div>
    </div>


    <script>
        // DOM 요소 (일부 수정 및 추가)
        const startScreenEl = document.getElementById('startScreen');
        const gameContainerEl = document.getElementById('gameContainer');
        const startGameBtnEl = document.getElementById('startGameBtn');
        const selectMapBtnEl = document.getElementById('selectMapBtn');
        const showRulesBtnEl = document.getElementById('showRulesBtn');
        const rulesModalEl = document.getElementById('rulesModal');
        const closeRulesModalBtn = document.getElementById('closeRulesModal');
        const mapSelectModalEl = document.getElementById('mapSelectModal');
        const closeMapModalBtn = document.getElementById('closeMapModal');
        const mapSelectionButtons = document.querySelectorAll('.map-selection button');

        const participantsInputEl = document.getElementById('participantsInput');
        const startButtonEl = document.getElementById('startButton');
        const participantsDisplayEl = document.getElementById('participantsDisplay');
        const battleLogEl = document.getElementById('battleLog');
        const winnerSectionEl = document.getElementById('winnerSection');
        const winnerNameEl = document.getElementById('winnerName');
        const resetButtonEl = document.getElementById('resetButton');
        const arenaSectionEl = document.getElementById('arena');
        const gameCanvasEl = document.getElementById('gameCanvas');
        const ctx = gameCanvasEl.getContext('2d');
        const gameStatsDisplayEl = document.getElementById('gameStatsDisplay');
        const speedControlsEl = document.querySelector('.speed-controls');
        const speed1xButton = document.getElementById('speed1x');
        const speed2xButton = document.getElementById('speed2x');
        const speed4xButton = document.getElementById('speed4x');


        // 게임 상태 변수
        let allPlayers = [];
        let items = [];
        let obstacles = [];
        let particles = []; 
        let attackEffects = []; 
        let gameLoopId;
        let gameOver = false;
        let uniqueIdCounter = 0; 
        let battleStatsLogInterval = 0; 
        let gameStartTime = 0; 
        let gameSpeedMultiplier = 1; 
        let isClutchCamActive = false; 
        let lastFrameTime = 0; 
        let baseNameColors = {}; 
        let selectedMapType = 'default'; 

        const PLAYER_RADIUS = 8;
        const PLAYER_HP = 100;
        const PLAYER_SPEED_BASE = 1.2; 
        const ATTACK_POWER_BASE = 3; 
        const ATTACK_RANGE_MELEE = PLAYER_RADIUS * 3.5; 
        const ATTACK_RANGE_RANGED = PLAYER_RADIUS * 15; 
        const ATTACK_COOLDOWN_BASE = 35; 
        const ATTACK_EFFECT_DURATION = 8; 
        const EVADE_DURATION_BASE = 20; 
        const ITEM_EFFECT_DURATION_BASE = 300; 
        const ULTIMATE_CHARGE_MAX = 100; 
        const ULTIMATE_CHARGE_PER_HIT = 5; 
        const ULTIMATE_CHARGE_PER_KILL = 20; 
        const ULTIMATE_DURATION_BASE = 180; 
        const ULTIMATE_COOLDOWN_BASE = 600; 
        
        const ITEM_RADIUS = 6; 
        const OBSTACLE_MIN_SIZE = 30;
        const OBSTACLE_MAX_SIZE = 60;
        const NUM_OBSTACLES_BASE = 4; 
        const NUM_PITS_BASE = 2; 
        const NUM_SPEED_PADS = 3; 
        const NUM_BUSHES = 4; 
        const NUM_ITEMS_MAX = 4; 
        const ITEM_SPAWN_INTERVAL_BASE = 60 * 8; 
        let itemSpawnTimer = 0;
        const PIT_DAMAGE = 0.2; 
        const PIT_SLOW_FACTOR = 0.6; 
        const SPEED_PAD_FACTOR = 1.8; 
        const SPEED_PAD_DURATION = 120; 
        const BUSH_OPACITY = 0.3; 

        const GRID_CELL_SIZE = PLAYER_RADIUS * 2.5; 
        let grid = [];
        const PATHFINDING_COOLDOWN_BASE = 25; 
        const PLAYER_CLASSES = { 
            'Brawler': '돌격자',
            'Berserker': '버서커',
            'Archer': '궁수',
            'Mage': '마법사'
        };
        const PLAYER_CLASS_KEYS = Object.keys(PLAYER_CLASSES); 

        const PREDEFINED_COLORS = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#FED766', '#2AB7CA', '#F0C419', '#A2D4AB', '#F8A5C2', '#8785A2', '#FFD166', '#06D6A0', '#118AB2', '#EF476F', '#FF9F1C', '#540D6E'];
        let colorIndex = 0;


        // --- A* 경로 탐색 알고리즘 시작 ---
        class Node {
            constructor(x, y, parent = null) {
                this.x = x; this.y = y; this.parent = parent;
                this.g = 0; this.h = 0; this.f = 0; 
            }
            equals(otherNode) { return this.x === otherNode.x && this.y === otherNode.y; }
        }
        function heuristic(nodeA, nodeB) { return Math.abs(nodeA.x - nodeB.x) + Math.abs(nodeA.y - nodeB.y); }
        function aStar(startX, startY, endX, endY, worldGrid) {
            const openList = []; const closedList = [];
            const startNode = new Node(startX, startY); const endNode = new Node(endX, endY);
            openList.push(startNode);
            while (openList.length > 0) {
                let lowestFIndex = 0;
                for (let i = 1; i < openList.length; i++) {
                    if (openList[i].f < openList[lowestFIndex].f) lowestFIndex = i;
                }
                const currentNode = openList[lowestFIndex];
                if (currentNode.equals(endNode)) {
                    const path = []; let temp = currentNode;
                    while (temp) { path.push({x: temp.x, y: temp.y}); temp = temp.parent; }
                    return path.reverse(); 
                }
                openList.splice(lowestFIndex, 1); closedList.push(currentNode);
                const directions = [[0, -1], [0, 1], [-1, 0], [1, 0]]; 
                for (const dir of directions) {
                    const nodeX = currentNode.x + dir[0]; const nodeY = currentNode.y + dir[1];
                    if (!worldGrid || worldGrid.length === 0 || !worldGrid[0] ||
                        nodeX < 0 || nodeX >= worldGrid[0].length || 
                        nodeY < 0 || nodeY >= worldGrid.length || 
                        worldGrid[nodeY][nodeX] === 1) continue; 
                    const neighborNode = new Node(nodeX, nodeY, currentNode);
                    if (closedList.some(node => node.equals(neighborNode))) continue;
                    neighborNode.g = currentNode.g + 1;
                    neighborNode.h = heuristic(neighborNode, endNode);
                    neighborNode.f = neighborNode.g + neighborNode.h;
                    if (!openList.some(node => node.equals(neighborNode) && neighborNode.g >= node.g)) {
                        openList.push(neighborNode);
                    }
                }
            }
            return []; 
        }
        // --- A* 경로 탐색 알고리즘 끝 ---

        // 파티클 클래스
        class Particle {
            constructor(x, y, color) {
                this.x = x; this.y = y; this.radius = Math.random() * 2 + 1;
                this.color = color; this.life = 20 + Math.random() * 20; 
                this.vx = (Math.random() - 0.5) * 4; 
                this.vy = (Math.random() - 0.5) * 4;
                this.opacity = 1;
            }
            update(deltaTime) { 
                this.x += this.vx * deltaTime; 
                this.y += this.vy * deltaTime; 
                this.life -= 1 * deltaTime; 
                this.opacity = Math.max(0, this.life / (20 + Math.random() * 20)); 
            }
            draw() {
                ctx.save(); ctx.globalAlpha = this.opacity;
                ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color; ctx.fill(); ctx.restore();
            }
        }

        // 공격 효과 클래스
        class AttackEffect {
            constructor(startX, startY, endX, endY, color, lineWidth = 1, shadowBlur = 5, type = 'line') {
                this.startX = startX; this.startY = startY;
                this.endX = endX; this.endY = endY;
                this.color = color; this.duration = ATTACK_EFFECT_DURATION / gameSpeedMultiplier; 
                this.currentFrame = 0;
                this.lineWidthBase = lineWidth;
                this.shadowBlurBase = shadowBlur;
                this.type = type; 
                if (type === 'projectile') {
                    this.px = startX; this.py = startY;
                    const angle = Math.atan2(endY - startY, endX - startX);
                    this.pvx = Math.cos(angle) * 15; 
                    this.pvy = Math.sin(angle) * 15;
                    this.duration = Math.hypot(endX-startX, endY-startY) / 15 / gameSpeedMultiplier; 
                }
            }
            update(deltaTime) { 
                this.currentFrame += 1 * deltaTime; 
                if (this.type === 'projectile') {
                    this.px += this.pvx * deltaTime;
                    this.py += this.pvy * deltaTime;
                }
            }
            draw() {
                const progress = this.currentFrame / this.duration;
                if (progress > 1 && this.type !== 'wave') return; 
                ctx.save();
                if (this.type === 'line') {
                    ctx.beginPath();
                    ctx.moveTo(this.startX, this.startY);
                    const dx = this.endX - this.startX;
                    const dy = this.endY - this.startY;
                    const length = Math.hypot(dx, dy);
                    const overshootFactor = 1.1; 
                    ctx.lineTo(this.startX + dx / length * (length * overshootFactor), this.startY + dy / length * (length * overshootFactor));
                    ctx.strokeStyle = this.color;
                    ctx.lineWidth = this.lineWidthBase + (1-progress) * (this.lineWidthBase * 1.5); 
                    ctx.shadowColor = this.color; 
                    ctx.shadowBlur = this.shadowBlurBase + (1-progress) * this.shadowBlurBase;
                    ctx.globalAlpha = 0.6 + (1 - progress) * 0.4; 
                    ctx.stroke();
                } else if (this.type === 'projectile') {
                    ctx.beginPath();
                    ctx.arc(this.px, this.py, PLAYER_RADIUS / 2, 0, Math.PI * 2);
                    ctx.fillStyle = this.color;
                    ctx.shadowColor = this.color; 
                    ctx.shadowBlur = 8;
                    ctx.fill();
                }
                ctx.restore();
            }
        }


        // 플레이어 클래스
        class Player {
            constructor(name, baseId, playerColor) { 
                this.baseName = name.split('_')[0]; 
                this.name = name; 
                this.id = `${baseId}-${uniqueIdCounter++}`;
                this.x = Math.random() * (gameCanvasEl.width - PLAYER_RADIUS * 2) + PLAYER_RADIUS;
                this.y = Math.random() * (gameCanvasEl.height - PLAYER_RADIUS * 2) + PLAYER_RADIUS;
                this.radius = PLAYER_RADIUS;
                const classKey = PLAYER_CLASS_KEYS[uniqueIdCounter % PLAYER_CLASS_KEYS.length];
                this.job = PLAYER_CLASSES[classKey]; 
                this.color = playerColor; 
                this.originalColor = this.color; 
                this.hp = PLAYER_HP;
                this.maxHp = PLAYER_HP;
                this.speed = PLAYER_SPEED_BASE;
                this.attackPower = ATTACK_POWER_BASE;
                this.attackRange = this.job === PLAYER_CLASSES['궁수'] || this.job === PLAYER_CLASSES['마법사'] ? ATTACK_RANGE_RANGED : ATTACK_RANGE_MELEE;
                this.attackCooldown = 0;
                this.target = null;
                this.isAlive = true;
                this.element = null; 
                this.vx = (Math.random() - 0.5) * 2 * this.speed; 
                this.vy = (Math.random() - 0.5) * 2 * this.speed;
                this.path = []; 
                this.pathfindingCooldown = 0;
                this.hitEffectTimer = 0; 
                this.kills = 0; 
                this.damageDealt = 0; 
                this.isEvading = false; 
                this.evadeTimer = 0;
                this.lastAttacker = null; 
                this.attackLungeTimer = 0; 
                this.activeItemEffects = {}; 
                this.ultimateCharge = 0;
                this.ultimateCooldown = 0;
                this.isUltimateActive = false;
                this.ultimateTimer = 0;
                this.survivalTime = 0; 
                this.itemsUsed = 0; 
                this.ultimatesUsed = 0; 
                this.isInPit = false; 
                this.pitDamageTimer = 0;
                this.isInBush = false; 
                this.speedPadEffectTimer = 0; 
            }

            draw() {
                if (!this.isAlive) return; 

                let displayColor = this.originalColor;
                let currentOpacity = 1.0;

                if (this.isInBush) {
                    currentOpacity = BUSH_OPACITY;
                }

                if (this.isUltimateActive) {
                    displayColor = `hsl(${ (Date.now()/10) % 360 }, 100%, 70%)`;
                } else if (this.hitEffectTimer > 0) {
                    displayColor = `rgba(255, 0, 0, ${0.5 + (this.hitEffectTimer / 10) * 0.5})`; 
                    this.hitEffectTimer--;
                } else if (this.activeItemEffects['speedBoost'] > 0 || this.speedPadEffectTimer > 0) {
                    displayColor = 'skyblue'; 
                } else if (this.activeItemEffects['attackBoost'] > 0) {
                    displayColor = 'orange'; 
                }
                
                ctx.save();
                ctx.globalAlpha = currentOpacity;

                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = displayColor;
                ctx.fill();
                ctx.strokeStyle = 'rgba(255,255,255,0.7)'; 
                ctx.lineWidth = 1.5;
                ctx.stroke();
                ctx.closePath();
                ctx.restore(); 


                const hpBarWidth = this.radius * 2.5;
                const hpBarHeight = 5;

                if (this.ultimateCharge > 0) {
                    const ultBarWidth = hpBarWidth; 
                    const ultBarHeight = 4;
                    const ultBarX = this.x - ultBarWidth / 2;
                    const ultBarY = this.y - this.radius - hpBarHeight - ultBarHeight - 7; 
                    ctx.fillStyle = '#505070'; 
                    ctx.fillRect(ultBarX, ultBarY, ultBarWidth, ultBarHeight);
                    ctx.strokeStyle = 'rgba(0,0,0,0.5)'; ctx.lineWidth = 0.5; ctx.strokeRect(ultBarX, ultBarY, ultBarWidth, ultBarHeight); 
                    const currentUltWidth = (this.ultimateCharge / ULTIMATE_CHARGE_MAX) * ultBarWidth;
                    ctx.fillStyle = '#ff00ff'; 
                    ctx.fillRect(ultBarX, ultBarY, currentUltWidth, ultBarHeight);
                }

                ctx.fillStyle = 'white';
                ctx.font = '14px Noto Sans KR'; 
                ctx.textAlign = 'center';
                ctx.shadowColor = 'black'; 
                ctx.shadowBlur = 4; 
                ctx.fillText(this.name, this.x, this.y - this.radius - 22); 
                ctx.font = '10px Noto Sans KR'; 
                ctx.fillStyle = '#cccccc';
                ctx.fillText(`(${this.job})`, this.x, this.y - this.radius - 8); 

                ctx.shadowBlur = 0; 

                const hpBarX = this.x - hpBarWidth / 2;
                const hpBarY = this.y - this.radius - hpBarHeight - 3; 
                ctx.fillStyle = '#333';
                ctx.fillRect(hpBarX, hpBarY, hpBarWidth, hpBarHeight);
                ctx.strokeStyle = 'rgba(0,0,0,0.5)'; ctx.lineWidth = 0.5; ctx.strokeRect(hpBarX, hpBarY, hpBarWidth, hpBarHeight); 
                const currentHpWidth = (this.hp / this.maxHp) * hpBarWidth;
                ctx.fillStyle = this.hp < this.maxHp * 0.3 ? '#f44336' : (this.hp < this.maxHp * 0.6 ? '#ffc107' : '#4caf50'); 
                ctx.fillRect(hpBarX, hpBarY, currentHpWidth, hpBarHeight);
            }

            update(players, worldGridRef, itemsArr, deltaTime) { 
                if (!this.isAlive) return;
                
                this.survivalTime += deltaTime; 

                for (const effect in this.activeItemEffects) {
                    if (this.activeItemEffects[effect] > 0) {
                        this.activeItemEffects[effect] -= 1 * deltaTime;
                        if (this.activeItemEffects[effect] <= 0) {
                            this.removeItemEffect(effect); 
                        }
                    }
                }
                if (this.ultimateCooldown > 0) this.ultimateCooldown -= 1 * deltaTime;
                if (this.isUltimateActive && this.ultimateTimer > 0) {
                    this.ultimateTimer -= 1 * deltaTime;
                    if (this.ultimateTimer <= 0) this.deactivateUltimate();
                }
                if (this.speedPadEffectTimer > 0) {
                    this.speedPadEffectTimer -= 1 * deltaTime;
                    if (this.speedPadEffectTimer <= 0) this.speed = PLAYER_SPEED_BASE; 
                }


                if (this.attackCooldown > 0) this.attackCooldown -= 1 * deltaTime;
                if (this.pathfindingCooldown > 0) this.pathfindingCooldown -= 1 * deltaTime;
                if (this.evadeTimer > 0) this.evadeTimer -= 1 * deltaTime; else this.isEvading = false;
                if (this.attackLungeTimer > 0) this.attackLungeTimer -= 1 * deltaTime;

                this.checkPitEffects(deltaTime);
                this.checkBushEffects();
                this.checkSpeedPadEffects();


                this.findTarget(players); 
                this.move(worldGridRef, deltaTime); 
                this.checkForItemPickup(itemsArr);

                if (this.ultimateCharge >= ULTIMATE_CHARGE_MAX && this.ultimateCooldown <= 0 && !this.isUltimateActive) {
                    this.activateUltimate(players);
                }


                if (this.target && this.target.isAlive && !this.isEvading && !this.isUltimateActive) { 
                    const distToTarget = Math.hypot(this.target.x - this.x, this.target.y - this.y);
                    if (distToTarget <= this.attackRange && this.attackCooldown <= 0) {
                        this.attack(this.target);
                    }
                }
                this.updateCardHP();
            }

            checkPitEffects(deltaTime) {
                this.isInPit = false; 
                let currentSpeedFactor = 1.0;
                for (const obs of obstacles) {
                    if (obs.type === 'pit') {
                        const distToPitCenter = Math.hypot(this.x - (obs.x + obs.width / 2), this.y - (obs.y + obs.height / 2));
                        if (distToPitCenter < obs.radius) { 
                            this.isInPit = true;
                            currentSpeedFactor = PIT_SLOW_FACTOR;
                            this.pitDamageTimer += deltaTime;
                            if (this.pitDamageTimer >= 60 / gameSpeedMultiplier) { 
                                this.takeDamage(PIT_DAMAGE * 60, {name: "구덩이"}); 
                                this.pitDamageTimer = 0;
                                logBattleMessage(`${this.name}이(가) 구덩이에 빠져 허우적댑니다! (-${(PIT_DAMAGE * 60).toFixed(1)} HP)`, 'log-pit');
                            }
                            break; 
                        }
                    }
                }
                let finalSpeed = PLAYER_SPEED_BASE * currentSpeedFactor;
                if (this.activeItemEffects['speedBoost'] > 0 || this.speedPadEffectTimer > 0) {
                    finalSpeed *= SPEED_PAD_FACTOR; 
                }
                this.speed = finalSpeed;

                if (!this.isInPit) this.pitDamageTimer = 0; 
            }

            checkBushEffects() {
                this.isInBush = false;
                for (const obs of obstacles) {
                    if (obs.type === 'bush') {
                        if (this.x > obs.x && this.x < obs.x + obs.width &&
                            this.y > obs.y && this.y < obs.y + obs.height) {
                            this.isInBush = true;
                            break;
                        }
                    }
                }
            }
            checkSpeedPadEffects() {
                if (this.speedPadEffectTimer > 0) return; 

                for (const obs of obstacles) {
                    if (obs.type === 'speedPad') {
                         const distToPadCenter = Math.hypot(this.x - (obs.x + obs.width / 2), this.y - (obs.y + obs.height / 2));
                        if (distToPadCenter < obs.width / 2) { 
                            this.speedPadEffectTimer = SPEED_PAD_DURATION / gameSpeedMultiplier;
                            this.speed = PLAYER_SPEED_BASE * SPEED_PAD_FACTOR;
                            logBattleMessage(`${this.name}이(가) 가속 발판을 밟았습니다!`, 'log-item');
                            break;
                        }
                    }
                }
            }
            
            findTarget(players) {
                let bestTarget = null;
                let highestScore = -Infinity;
                const alivePlayerCount = players.filter(p => p.isAlive).length;

                players.forEach(p => {
                    if (p === this || !p.isAlive || p.isInBush) return; 
                    if (p.baseName === this.baseName && p.id !== this.id) return;
                    
                    let score = 0;
                    const distance = Math.hypot(this.x - p.x, this.y - p.y);
                    score += (gameCanvasEl.width - distance) / 10; 
                    score += (PLAYER_HP - p.hp) / 2; 
                    if (p === this.lastAttacker && this.lastAttacker.isAlive) {
                        score += 50; 
                    }
                    if (p === this.target) {
                        score += 20;
                    }

                    if (alivePlayerCount > 3 && p.hp > PLAYER_HP * 0.7) {
                        score += 30; 
                    }


                    if (score > highestScore) {
                        highestScore = score;
                        bestTarget = p;
                    }
                });
                this.target = bestTarget;
            }

            move(worldGridRef, deltaTime) { 
                let targetVx = 0;
                let targetVy = 0;
                const currentSpeed = this.speed * deltaTime; 

                if (this.isEvading && this.lastAttacker && this.lastAttacker.isAlive) { 
                    const angleFromAttacker = Math.atan2(this.y - this.lastAttacker.y, this.x - this.lastAttacker.x);
                    targetVx = Math.cos(angleFromAttacker) * currentSpeed * 1.2; 
                    targetVy = Math.sin(angleFromAttacker) * currentSpeed * 1.2;
                } else if (this.attackLungeTimer > 0 && this.target && this.target.isAlive) { 
                     const angleToTarget = Math.atan2(this.target.y - this.y, this.target.x - this.x);
                     targetVx = Math.cos(angleToTarget) * currentSpeed * 1.5; 
                     targetVy = Math.sin(angleToTarget) * currentSpeed * 1.5;
                }
                else if (this.target && this.target.isAlive) { 
                    if (this.pathfindingCooldown <= 0 && worldGridRef && worldGridRef.length > 0 && worldGridRef[0] && worldGridRef[0].length > 0) {
                        const startGridX = Math.floor(this.x / GRID_CELL_SIZE);
                        const startGridY = Math.floor(this.y / GRID_CELL_SIZE);
                        const endGridX = Math.floor(this.target.x / GRID_CELL_SIZE);
                        const endGridY = Math.floor(this.target.y / GRID_CELL_SIZE);
                        if (startGridX >=0 && startGridY >=0 && endGridX >=0 && endGridY >=0 &&
                            startGridX < worldGridRef[0].length && startGridY < worldGridRef.length &&
                            endGridX < worldGridRef[0].length && endGridY < worldGridRef.length) { 
                            if (startGridX !== endGridX || startGridY !== endGridY) {
                                this.path = aStar(startGridX, startGridY, endGridX, endGridY, worldGridRef);
                            } else { this.path = []; }
                        } else {
                            this.path = []; 
                        }
                        this.pathfindingCooldown = PATHFINDING_COOLDOWN_BASE / gameSpeedMultiplier; 
                    }

                    if (this.path.length > 0) {
                        const nextWaypointGrid = this.path[0];
                        const nextWaypointX = nextWaypointGrid.x * GRID_CELL_SIZE + GRID_CELL_SIZE / 2;
                        const nextWaypointY = nextWaypointGrid.y * GRID_CELL_SIZE + GRID_CELL_SIZE / 2;
                        const angleToWaypoint = Math.atan2(nextWaypointY - this.y, nextWaypointX - this.x);
                        targetVx = Math.cos(angleToWaypoint) * currentSpeed;
                        targetVy = Math.sin(angleToWaypoint) * currentSpeed;
                        if (Math.hypot(nextWaypointX - this.x, nextWaypointY - this.y) < this.radius * 1.5) {
                            this.path.shift();
                        }
                    } else { 
                        const angleToTarget = Math.atan2(this.target.y - this.y, this.target.x - this.x);
                        targetVx = Math.cos(angleToTarget) * currentSpeed;
                        targetVy = Math.sin(angleToTarget) * currentSpeed;
                    }
                } else { 
                    if (Math.random() < 0.02 || (this.vx === 0 && this.vy === 0) ) { 
                        this.vx = (Math.random() - 0.5) * 2 * currentSpeed * 0.7; 
                        this.vy = (Math.random() - 0.5) * 2 * currentSpeed * 0.7;
                    }
                    targetVx = this.vx; targetVy = this.vy;
                }
                
                let nextX = this.x + targetVx;
                let nextY = this.y + targetVy;

                for (const obs of obstacles) {
                    if (obs.type === 'pit' || obs.type === 'bush' || obs.type === 'speedPad') continue; 

                    const futurePlayerRect = { x: nextX - this.radius, y: nextY - this.radius, width: this.radius * 2, height: this.radius * 2 };
                    const obstacleRect = { x: obs.x, y: obs.y, width: obs.width, height: obs.height };

                    if (futurePlayerRect.x < obstacleRect.x + obstacleRect.width &&
                        futurePlayerRect.x + futurePlayerRect.width > obstacleRect.x &&
                        futurePlayerRect.y < obstacleRect.y + obstacleRect.height &&
                        futurePlayerRect.y + futurePlayerRect.height > obstacleRect.y) {
                        
                        const overlapX = (this.radius + obs.width / 2) - Math.abs((nextX) - (obs.x + obs.width / 2));
                        const overlapY = (this.radius + obs.height / 2) - Math.abs((nextY) - (obs.y + obs.height / 2));


                        if (overlapX > 0 && overlapY > 0) { 
                             if (overlapX < overlapY) { 
                                if ((nextX) < (obs.x + obs.width/2)) { 
                                    nextX -= overlapX * 1.1; 
                                } else { 
                                    nextX += overlapX * 1.1;
                                }
                                this.vx *= -0.3; 
                            } else { 
                                if ((nextY) < (obs.y + obs.height/2)) { 
                                    nextY -= overlapY * 1.1;
                                } else { 
                                    nextY += overlapY * 1.1;
                                }
                                this.vy *= -0.3;
                            }
                        }
                        this.path = []; 
                        this.pathfindingCooldown = 0; 
                    }
                }


                if (nextX - this.radius < 0) { nextX = this.radius; this.vx *= -0.5; } 
                if (nextX + this.radius > gameCanvasEl.width) { nextX = gameCanvasEl.width - this.radius; this.vx *= -0.5; }
                if (nextY - this.radius < 0) { nextY = this.radius; this.vy *= -0.5; }
                if (nextY + this.radius > gameCanvasEl.height) { nextY = gameCanvasEl.height - this.radius; this.vy *= -0.5; }
                
                this.x = nextX; this.y = nextY;
            }

            attack(target) {
                const damageDealt = this.attackPower; 
                target.takeDamage(damageDealt, this); 
                this.damageDealt += damageDealt; 
                this.ultimateCharge = Math.min(ULTIMATE_CHARGE_MAX, this.ultimateCharge + ULTIMATE_CHARGE_PER_HIT);
                this.attackCooldown = ATTACK_COOLDOWN_BASE / gameSpeedMultiplier;
                this.attackLungeTimer = 5 / gameSpeedMultiplier; 
                
                if (this.job === PLAYER_CLASSES['궁수'] || this.job === PLAYER_CLASSES['마법사']) {
                    attackEffects.push(new AttackEffect(this.x, this.y, target.x, target.y, this.job === PLAYER_CLASSES['궁수'] ? 'lightgray' : 'violet', 1, 3, 'projectile'));
                } else {
                    attackEffects.push(new AttackEffect(this.x, this.y, target.x, target.y, 'rgba(255, 80, 80, 0.9)'));
                }

                if (this.job === PLAYER_CLASSES['돌격자'] && Math.random() < 0.3) { 
                    target.takeKnockback(this.x, this.y, 30);
                    logBattleMessage(`${this.name}이(가) ${target.name}을(를) 밀쳐냈습니다!`, 'log-event');
                }

                this.isEvading = true;
                this.evadeTimer = EVADE_DURATION_BASE / gameSpeedMultiplier;
                this.lastAttacker = target; 
            }

            takeKnockback(attackerX, attackerY, power) {
                const angle = Math.atan2(this.y - attackerY, this.x - attackerX);
                this.vx += Math.cos(angle) * power / 5; 
                this.vy += Math.sin(angle) * power / 5;
            }


            takeDamage(damage, attacker) {
                this.hp -= damage;
                this.hitEffectTimer = 8; 
                this.lastAttacker = attacker; 

                if (this.element) { 
                    this.element.style.transition = 'background-color 0.05s'; 
                    this.element.style.backgroundColor = '#b71c1c'; 
                    setTimeout(() => {
                        if (this.element && this.isAlive) this.element.style.backgroundColor = '#3a3a4e';
                    }, 50);
                }
                if (this.hp <= 0) {
                    this.hp = 0;
                    if (this.isAlive) { 
                        this.isAlive = false;
                        if (attacker && attacker.kills !== undefined) { 
                            attacker.kills++; 
                            attacker.ultimateCharge = Math.min(ULTIMATE_CHARGE_MAX, attacker.ultimateCharge + ULTIMATE_CHARGE_PER_KILL);
                        }
                        logBattleMessage(`💥 ${this.name} 플레이어가 ${attacker.name}의 공격에 결정타를 맞고 탈락했습니다!`, 'log-event');
                        if (this.element) {
                            this.element.classList.add('eliminated');
                        }
                        for (let i = 0; i < 25; i++) { 
                            particles.push(new Particle(this.x, this.y, this.originalColor));
                        }
                    }
                }
                this.updateCardHP();
            }
            
            checkForItemPickup(itemsArr) {
                for (let i = itemsArr.length - 1; i >= 0; i--) {
                    const item = itemsArr[i];
                    const distToItem = Math.hypot(item.x - this.x, item.y - this.y);
                    if (distToItem < this.radius + item.radius) {
                        this.applyItemEffect(item);
                        itemsArr.splice(i, 1); 
                        break;
                    }
                }
            }

            applyItemEffect(item) {
                this.itemsUsed++; 
                if (item.type === 'health') {
                    this.hp = Math.min(this.maxHp, this.hp + 35); 
                    logBattleMessage(`💚 ${this.name} 플레이어가 구급상자를 발견하여 체력을 회복합니다! (HP: ${this.hp.toFixed(0)})`, 'log-item');
                } else if (item.type === 'speedBoost') {
                    this.activeItemEffects['speedBoost'] = ITEM_EFFECT_DURATION_BASE / gameSpeedMultiplier;
                    this.speed = PLAYER_SPEED_BASE * 1.5; 
                    logBattleMessage(`⚡ ${this.name} 플레이어가 스피드 부스트를 획득! 이동 속도가 빨라집니다!`, 'log-item');
                } else if (item.type === 'attackBoost') {
                    this.activeItemEffects['attackBoost'] = ITEM_EFFECT_DURATION_BASE / gameSpeedMultiplier;
                    this.attackPower = ATTACK_POWER_BASE * 1.5; 
                    logBattleMessage(`🔥 ${this.name} 플레이어가 공격력 강화 아이템을 획득! 공격력이 강력해집니다!`, 'log-item');
                }
                this.updateCardHP();
            }

            removeItemEffect(effectType) {
                if (effectType === 'speedBoost') {
                    this.speed = PLAYER_SPEED_BASE;
                    // logBattleMessage(`💨 ${this.name} 플레이어의 스피드 부스트 효과가 종료되었습니다.`, 'log-item'); // 너무 많은 로그 방지
                } else if (effectType === 'attackBoost') {
                    this.attackPower = ATTACK_POWER_BASE;
                    // logBattleMessage(`⚔️ ${this.name} 플레이어의 공격력 강화 효과가 종료되었습니다.`, 'log-item');
                }
            }

            activateUltimate(players) {
                this.isUltimateActive = true;
                this.ultimateTimer = ULTIMATE_DURATION_BASE / gameSpeedMultiplier; 
                this.ultimateCharge = 0;
                this.ultimateCooldown = ULTIMATE_COOLDOWN_BASE / gameSpeedMultiplier; 
                this.ultimatesUsed++; 
                let ultimateName = "필살기";
                let ultimateDamage = this.attackPower * 1.5; 
                const ultimateRange = this.radius * 6;

                if (this.job === PLAYER_CLASSES['돌격자']) {
                    ultimateName = "<<지각 변동>>";
                    ultimateDamage = this.attackPower * 1.2;
                    logBattleMessage(`🔨 ${this.name}(${this.job})의 필살기 ${ultimateName}! 주변 모든 적을 밀쳐내고 기절시킵니다!`, 'log-ultimate');
                    attackEffects.push({ x: this.x, y: this.y, radius: 0, maxRadius: ultimateRange, duration: 20 / gameSpeedMultiplier, currentFrame: 0, color: 'rgba(165, 42, 42, 0.6)', type: 'wave',
                        update: function(dt) { this.currentFrame+=dt; this.radius = (this.currentFrame / (20/gameSpeedMultiplier)) * this.maxRadius; },
                        draw: function() { if (this.currentFrame >= (20/gameSpeedMultiplier)) return; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.strokeStyle = this.color; ctx.lineWidth = 5; ctx.stroke(); }
                    });
                    players.forEach(p => {
                        if (p !== this && p.isAlive) {
                            const distance = Math.hypot(this.x - p.x, this.y - p.y);
                            if (distance <= ultimateRange) {
                                p.takeDamage(ultimateDamage, this);
                                p.takeKnockback(this.x, this.y, 80); 
                                p.evadeTimer = 60 / gameSpeedMultiplier; 
                            }
                        }
                    });
                } else if (this.job === PLAYER_CLASSES['버서커']) {
                    ultimateName = "<<광전사의 분노>>";
                    this.speed *= 1.5;
                    this.attackPower *= 1.8;
                    logBattleMessage(`😡 ${this.name}(${this.job})의 필살기 ${ultimateName}! 공격력과 속도가 폭주합니다!`, 'log-ultimate');
                } else if (this.job === PLAYER_CLASSES['궁수']) {
                    ultimateName = "<<화살 폭풍>>";
                    logBattleMessage(`🏹 ${this.name}(${this.job})의 필살기 ${ultimateName}! 여러 방향으로 화살을 난사합니다!`, 'log-ultimate');
                    for (let i = 0; i < 8; i++) { 
                        const angle = (i / 8) * Math.PI * 2;
                        const endX = this.x + Math.cos(angle) * ATTACK_RANGE_RANGED;
                        const endY = this.y + Math.sin(angle) * ATTACK_RANGE_RANGED;
                        attackEffects.push(new AttackEffect(this.x, this.y, endX, endY, 'silver', 2, 5, 'projectile'));
                        players.forEach(p => {
                            if (p !== this && p.isAlive && Math.hypot(p.x - this.x, p.y - this.y) < ATTACK_RANGE_RANGED * 0.7) { 
                                p.takeDamage(this.attackPower * 0.5, this); 
                            }
                        });
                    }
                } else if (this.job === PLAYER_CLASSES['마법사']) {
                    ultimateName = "<<얼음 폭풍>>";
                    const stormRadius = this.radius * 10;
                    logBattleMessage(`❄️ ${this.name}(${this.job})의 필살기 ${ultimateName}! 지정 범위에 얼음 폭풍을 소환합니다!`, 'log-ultimate');
                     attackEffects.push({ x: this.x, y: this.y, radius: stormRadius, duration: ULTIMATE_DURATION_BASE / gameSpeedMultiplier, currentFrame: 0, color: 'rgba(173, 216, 230, 0.3)', type: 'static_aoe',
                        update: function(dt) { this.currentFrame+=dt; },
                        draw: function() { 
                            if (this.currentFrame >= this.duration) return;
                            const alpha = 0.3 + Math.sin(this.currentFrame * 0.1) * 0.1;
                            ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); 
                            ctx.fillStyle = `rgba(173, 216, 230, ${alpha})`; ctx.fill(); 
                        }
                    });
                    players.forEach(p => {
                        if (p !== this && p.isAlive) {
                            const distance = Math.hypot(this.x - p.x, this.y - p.y);
                            if (distance <= stormRadius) {
                                p.takeDamage(ultimateDamage * 0.1, this); 
                                p.speed *= 0.7; 
                                setTimeout(() => { if(p.isAlive) p.speed = PLAYER_SPEED_BASE; }, ULTIMATE_DURATION_BASE / gameSpeedMultiplier * 1000/60); 
                            }
                        }
                    });
                }
            }
            deactivateUltimate() {
                this.isUltimateActive = false;
                if (this.job === PLAYER_CLASSES['버서커']) { 
                    this.speed = PLAYER_SPEED_BASE;
                    this.attackPower = ATTACK_POWER_BASE;
                }
            }
            
            updateCardHP() {
                if (this.element) {
                    const hpBar = this.element.querySelector('.hp-bar');
                    if (hpBar) {
                        hpBar.style.width = `${(this.hp / this.maxHp) * 100}%`;
                    }
                    if (this.hp < this.maxHp * 0.3) {
                        this.element.classList.add('low-hp');
                    } else {
                        this.element.classList.remove('low-hp');
                    }
                }
            }
        }

        // 아이템 클래스
        class Item {
            constructor(x, y, type) {
                this.x = x; this.y = y; this.radius = ITEM_RADIUS;
                this.type = type; 
                this.pulseSize = Math.random() * Math.PI; 
                this.pulseSpeed = 0.08 + Math.random() * 0.04; 
                switch(type) {
                    case 'health': this.color = 'lime'; this.symbol = '✚'; break;
                    case 'speedBoost': this.color = 'deepskyblue'; this.symbol = '⚡'; break;
                    case 'attackBoost': this.color = 'orangered'; this.symbol = '🔥'; break;
                    default: this.color = 'gold'; this.symbol = '?';
                }
            }
            update(deltaTime) { 
                this.pulseSize += this.pulseSpeed * deltaTime;
                if (this.pulseSize > Math.PI * 2) this.pulseSize = 0;
            }
            draw() {
                const currentRadius = this.radius + Math.sin(this.pulseSize) * 2; 
                ctx.beginPath(); ctx.arc(this.x, this.y, currentRadius, 0, Math.PI * 2);
                ctx.fillStyle = this.color; 
                ctx.shadowColor = this.color; ctx.shadowBlur = 10;
                ctx.fill(); 
                ctx.shadowBlur = 0; 
                ctx.fillStyle = 'white';
                ctx.font = `${currentRadius * 1.2}px Noto Sans KR`; 
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.symbol, this.x, this.y);
                ctx.closePath();
            }
        }

        // 장애물 클래스
        class Obstacle {
            constructor(x, y, width, height, type = 'wall') { 
                this.x = x; this.y = y; this.width = width; this.height = height;
                this.type = type;
                if (type === 'pit') {
                    this.color = `hsl(30, 25%, ${Math.random()*10 + 20}%)`; 
                    this.isRound = true; 
                    this.radius = Math.min(width, height) / 2; 
                } else if (type === 'bush') {
                    this.color = `rgba(34, 139, 34, 0.7)`; 
                    this.isRound = false;
                } else if (type === 'speedPad') {
                    this.color = `rgba(0, 191, 255, 0.5)`; 
                    this.isRound = true;
                    this.radius = Math.min(width, height) / 2;
                }
                else {
                    this.color = `hsl(230, 20%, ${Math.random()*10 + 35}%)`; 
                    this.isRound = false;
                }
            }
            draw() {
                ctx.fillStyle = this.color; 
                ctx.strokeStyle = `hsl(230, 25%, ${Math.random()*5 + (this.type === 'pit' ? 25 : 50)}%)`; 
                ctx.lineWidth = 2;
                ctx.beginPath();
                if (this.isRound) {
                    ctx.arc(this.x + this.width/2, this.y + this.height/2, this.radius, 0, Math.PI * 2);
                    if (this.type === 'pit') {
                        ctx.fillStyle = `hsla(30, 25%, 15%, 0.7)`; 
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(this.x + this.width/2, this.y + this.height/2, this.radius * 0.7, 0, Math.PI * 2);
                        ctx.fillStyle = `hsla(30, 25%, 10%, 0.8)`; 
                        ctx.fill();
                    } else {
                         ctx.fill();
                    }
                } else {
                    const r = 8; 
                    ctx.moveTo(this.x + r, this.y);
                    ctx.lineTo(this.x + this.width - r, this.y);
                    ctx.quadraticCurveTo(this.x + this.width, this.y, this.x + this.width, this.y + r);
                    ctx.lineTo(this.x + this.width, this.y + this.height - r);
                    ctx.quadraticCurveTo(this.x + this.width, this.y + this.height, this.x + this.width - r, this.y + this.height);
                    ctx.lineTo(this.x + r, this.y + this.height);
                    ctx.quadraticCurveTo(this.x, this.y + this.height, this.x, this.y + this.height - r);
                    ctx.lineTo(this.x, this.y + r);
                    ctx.quadraticCurveTo(this.x, this.y, this.x + r, this.y);
                    ctx.closePath();
                    ctx.fill();
                    if (this.type === 'wall') ctx.stroke(); 
                }
            }
        }
        

        // 게임 초기화 및 시작
        function initializeGameScreen() {
            startScreenEl.style.display = 'none';
            gameContainerEl.style.display = 'block';
            arenaSectionEl.style.display = 'none'; 
            winnerSectionEl.style.display = 'none';
            speedControlsEl.style.display = 'none';
        }

        startGameBtnEl.addEventListener('click', () => {
            initializeGameScreen();
            if (!selectedMapType) selectedMapType = 'default'; 
        });

        showRulesBtnEl.addEventListener('click', () => {
            rulesModalEl.style.display = 'block';
        });
        closeRulesModalBtn.addEventListener('click', () => {
            rulesModalEl.style.display = 'none';
        });

        selectMapBtnEl.addEventListener('click', () => {
            mapSelectModalEl.style.display = 'block';
        });
        closeMapModalBtn.addEventListener('click', () => {
            mapSelectModalEl.style.display = 'none';
        });
        mapSelectionButtons.forEach(button => {
            button.addEventListener('click', (event) => {
                selectedMapType = event.target.dataset.map;
                mapSelectModalEl.style.display = 'none';
                initializeGameScreen(); 
                logBattleMessage(`맵 선택: ${event.target.textContent}`, 'log-event');
            });
        });
        window.addEventListener('click', (event) => { 
            if (event.target == rulesModalEl) rulesModalEl.style.display = "none";
            if (event.target == mapSelectModalEl) mapSelectModalEl.style.display = "none";
        });


        function setupBattle() {
            const namesString = participantsInputEl.value.trim();
            if (!namesString) { alertUser("참가자 명단을 입력해주세요!"); return; }
            const parsedNames = [];
            baseNameColors = {}; 
            colorIndex = 0; 

            namesString.split(',').forEach(part => {
                part = part.trim(); if (!part) return;
                if (part.includes('*')) {
                    const [name, countStr] = part.split('*');
                    const baseName = name.trim();
                    const count = parseInt(countStr, 10);
                    if (baseName && !isNaN(count) && count > 0) {
                        if (!baseNameColors[baseName]) { 
                            baseNameColors[baseName] = PREDEFINED_COLORS[colorIndex % PREDEFINED_COLORS.length];
                            colorIndex++;
                        }
                        for (let i = 0; i < count; i++) {
                            parsedNames.push(`${baseName}_${i + 1}`); 
                        }
                    } else { parsedNames.push(part); }
                } else { 
                    const baseName = part;
                     if (!baseNameColors[baseName]) {
                        baseNameColors[baseName] = PREDEFINED_COLORS[colorIndex % PREDEFINED_COLORS.length];
                        colorIndex++;
                    }
                    parsedNames.push(part); 
                }
            });
            if (parsedNames.length === 0 || (parsedNames.length === 1 && parsedNames[0] === "")) {
                 alertUser("유효한 참가자가 없습니다. 이름을 다시 입력해주세요."); return;
            }
            gameOver = false; uniqueIdCounter = 0; particles = []; attackEffects = [];
            battleStatsLogInterval = 0; itemSpawnTimer = 0;
            arenaSectionEl.style.display = 'block';
            speedControlsEl.style.display = 'block'; 
            gameStartTime = Date.now(); 
            requestAnimationFrame(() => {
                initGameArena(); 
                allPlayers = parsedNames.map((name, index) => {
                    const baseName = name.split('_')[0];
                    return new Player(name, `p${index}`, baseNameColors[baseName] || `hsl(${Math.random() * 360}, 80%, 60%)`);
                });
                displayParticipantCards();
                winnerSectionEl.style.display = 'none'; 
                gameStatsDisplayEl.innerHTML = ''; 
                battleLogEl.innerHTML = ''; 
                logBattleMessage('⚔️ 아레나의 문이 열렸습니다! 전투 시작! ⚔️', 'log-event');
                startButtonEl.disabled = true; participantsInputEl.disabled = true;
                if (allPlayers.length === 1) {
                    setTimeout(() => declareWinner(allPlayers[0]), 1000 / gameSpeedMultiplier);
                } else if (allPlayers.length > 1) {
                    lastFrameTime = performance.now(); 
                    setTimeout(startGameLoop, 1000 / gameSpeedMultiplier);
                }
            });
        }
        
        function displayParticipantCards() {
            participantsDisplayEl.innerHTML = '';
            allPlayers.forEach(player => {
                const card = document.createElement('div');
                card.classList.add('participant-card');
                card.id = `card-${player.id}`;
                
                const nameSpan = document.createElement('span');
                nameSpan.textContent = player.name;
                card.appendChild(nameSpan);

                const jobSpan = document.createElement('span');
                jobSpan.classList.add('job-display');
                jobSpan.textContent = `(${player.job})`;
                card.appendChild(jobSpan);

                const hpBarContainer = document.createElement('div');
                hpBarContainer.classList.add('hp-bar-container');
                const hpBar = document.createElement('div');
                hpBar.classList.add('hp-bar');
                hpBarContainer.appendChild(hpBar);
                card.appendChild(hpBarContainer);
                player.element = card; 
                participantsDisplayEl.appendChild(card);
                player.updateCardHP(); 
            });
        }

        function initGameArena() {
            gameCanvasEl.width = gameCanvasEl.offsetWidth; 
            gameCanvasEl.height = gameCanvasEl.offsetHeight;
            const gridCols = Math.floor(gameCanvasEl.width / GRID_CELL_SIZE);
            const gridRows = Math.floor(gameCanvasEl.height / GRID_CELL_SIZE);
            if (gridRows <= 0 || gridCols <= 0) {
                grid = [[0]]; obstacles = []; items = []; return; 
            }
            grid = Array(gridRows).fill(null).map(() => Array(gridCols).fill(0));
            obstacles = [];

            if (selectedMapType === 'narrow') {
                const passageWidthCells = 5; // 통로 너비 (셀 단위)
                const passageWidthPixels = passageWidthCells * GRID_CELL_SIZE;
                const wallWidthPixels = (gameCanvasEl.width - passageWidthPixels) / 2;

                if (wallWidthPixels > 0) {
                    obstacles.push(new Obstacle(0, 0, wallWidthPixels, gameCanvasEl.height, 'wall'));
                    obstacles.push(new Obstacle(wallWidthPixels + passageWidthPixels, 0, wallWidthPixels, gameCanvasEl.height, 'wall'));
                }
                for (let i = 0; i < 3; i++) {
                    const size = OBSTACLE_MIN_SIZE;
                    obstacles.push(new Obstacle(wallWidthPixels + Math.random()*(passageWidthPixels - size), Math.random()*(gameCanvasEl.height - size), size, size, 'wall'));
                }
            } else if (selectedMapType === 'wide') {
                for (let i = 0; i < NUM_OBSTACLES_BASE - 2; i++) {
                    const sizeW = Math.random() * (OBSTACLE_MAX_SIZE - OBSTACLE_MIN_SIZE) + OBSTACLE_MIN_SIZE;
                    const sizeH = Math.random() * (OBSTACLE_MAX_SIZE - OBSTACLE_MIN_SIZE) + OBSTACLE_MIN_SIZE;
                    let obsX, obsY;
                    do {
                        obsX = Math.random() * (gameCanvasEl.width - sizeW);
                        obsY = Math.random() * (gameCanvasEl.height - sizeH);
                    } while (obsX > gameCanvasEl.width * 0.3 && obsX < gameCanvasEl.width * 0.7 &&
                             obsY > gameCanvasEl.height * 0.3 && obsY < gameCanvasEl.height * 0.7);
                    obstacles.push(new Obstacle(obsX, obsY, sizeW, sizeH, 'wall'));
                }
            } else { 
                for (let i = 0; i < NUM_OBSTACLES_BASE; i++) {
                    const sizeW = Math.random() * (OBSTACLE_MAX_SIZE - OBSTACLE_MIN_SIZE) + OBSTACLE_MIN_SIZE;
                    const sizeH = Math.random() * (OBSTACLE_MAX_SIZE - OBSTACLE_MIN_SIZE) + OBSTACLE_MIN_SIZE;
                    const obsX = Math.random() * (gameCanvasEl.width - sizeW);
                    const obsY = Math.random() * (gameCanvasEl.height - sizeH);
                    obstacles.push(new Obstacle(obsX, obsY, sizeW, sizeH, 'wall'));
                }
            }
            
            obstacles.filter(o => o.type === 'wall').forEach(obs => {
                const startCol = Math.max(0, Math.floor(obs.x / GRID_CELL_SIZE));
                const endCol = Math.min(gridCols - 1, Math.floor((obs.x + obs.width) / GRID_CELL_SIZE));
                const startRow = Math.max(0, Math.floor(obs.y / GRID_CELL_SIZE));
                const endRow = Math.min(gridRows - 1, Math.floor((obs.y + obs.height) / GRID_CELL_SIZE));
                for (let r = startRow; r <= endRow; r++) {
                    for (let c = startCol; c <= endCol; c++) {
                        if (grid[r] && grid[r][c] !== undefined) grid[r][c] = 1; 
                    }
                }
            });


            for (let i = 0; i < NUM_PITS_BASE; i++) {
                const pitRadius = (Math.random() * (OBSTACLE_MAX_SIZE - OBSTACLE_MIN_SIZE) + OBSTACLE_MIN_SIZE) / 2;
                obstacles.push(new Obstacle(Math.random() * (gameCanvasEl.width - pitRadius*2), Math.random() * (gameCanvasEl.height - pitRadius*2), pitRadius*2, pitRadius*2, 'pit'));
            }
            for (let i = 0; i < NUM_SPEED_PADS; i++) {
                const padSize = PLAYER_RADIUS * 3;
                obstacles.push(new Obstacle(Math.random()*(gameCanvasEl.width - padSize), Math.random()*(gameCanvasEl.height - padSize), padSize, padSize, 'speedPad'));
            }
            for (let i = 0; i < NUM_BUSHES; i++) {
                const bushSize = PLAYER_RADIUS * 5;
                obstacles.push(new Obstacle(Math.random()*(gameCanvasEl.width - bushSize), Math.random()*(gameCanvasEl.height - bushSize), bushSize, bushSize, 'bush'));
            }


            items = []; 
            spawnInitialItems();
        }

        function spawnInitialItems() {
            for (let i = 0; i < Math.floor(NUM_ITEMS_MAX / 2) ; i++) { 
                spawnNewItem();
            }
        }

        function spawnNewItem() {
            if (items.length >= NUM_ITEMS_MAX) return; 
            const itemTypes = ['health', 'speedBoost', 'attackBoost'];
            const type = itemTypes[Math.floor(Math.random() * itemTypes.length)];
            let itemX, itemY, itemGridX, itemGridY;
            let attempts = 0; const maxAttempts = 20; 
            do {
                itemX = Math.random() * (gameCanvasEl.width - ITEM_RADIUS * 2) + ITEM_RADIUS;
                itemY = Math.random() * (gameCanvasEl.height - ITEM_RADIUS * 2) + ITEM_RADIUS;
                itemGridX = Math.floor(itemX / GRID_CELL_SIZE);
                itemGridY = Math.floor(itemY / GRID_CELL_SIZE);
                attempts++;
            } while (
                attempts < maxAttempts &&
                (itemGridY < 0 || itemGridY >= grid.length || 
                 itemGridX < 0 || !grid[itemGridY] || itemGridX >= grid[itemGridY].length || 
                 grid[itemGridY][itemGridX] === 1) 
            );
            if (attempts < maxAttempts) { items.push(new Item(itemX, itemY, type)); }
        }


        function startGameLoop() {
            if (gameOver) return; 
            gameLoopId = requestAnimationFrame(gameLoop);
        }

        function gameLoop(currentTime) { 
            if (gameOver) { cancelAnimationFrame(gameLoopId); return; }

            const deltaTime = (currentTime - lastFrameTime) / (1000 / 60) * gameSpeedMultiplier; 
            lastFrameTime = currentTime;


            ctx.save(); 
            ctx.clearRect(0, 0, gameCanvasEl.width, gameCanvasEl.height);

            const alivePlayers = allPlayers.filter(p => p.isAlive);
            
            if (alivePlayers.length >= 2 && alivePlayers.length <= 3 && allPlayers.length > 3) { 
                if (!isClutchCamActive) {
                    isClutchCamActive = true;
                }
                let centerX = 0;
                let centerY = 0;
                alivePlayers.forEach(p => { centerX += p.x; centerY += p.y; });
                centerX /= alivePlayers.length;
                centerY /= alivePlayers.length;

                const scale = 1.5; 
                const translateX = gameCanvasEl.width / 2 - centerX * scale;
                const translateY = gameCanvasEl.height / 2 - centerY * scale;
                
                ctx.translate(translateX, translateY);
                ctx.scale(scale, scale);

            } else {
                if (isClutchCamActive) {
                    isClutchCamActive = false;
                }
            }
            
            items.forEach(i => { i.update(deltaTime); i.draw(); }); 
            obstacles.forEach(o => o.draw());
            
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].update(deltaTime); particles[i].draw(); 
                if (particles[i].life <= 0) particles.splice(i, 1);
            }
            for (let i = attackEffects.length - 1; i >= 0; i--) {
                attackEffects[i].update(deltaTime); attackEffects[i].draw(); 
                if (attackEffects[i].currentFrame >= attackEffects[i].duration && (!attackEffects[i].type || attackEffects[i].type !== 'wave')) { 
                    attackEffects.splice(i, 1);
                } else if (attackEffects[i].type === 'wave' && attackEffects[i].currentFrame >= attackEffects[i].duration) {
                     attackEffects.splice(i, 1);
                }
            }
            
            alivePlayers.forEach(player => {
                player.update(allPlayers, grid, items, deltaTime); player.draw(); 
            });
            
            ctx.restore(); 

            battleStatsLogInterval += deltaTime;
            if (battleStatsLogInterval >= (60 * 7) && alivePlayers.length > 1) { 
                updateBattleStatsLog(alivePlayers);
                battleStatsLogInterval = 0;
            }

            itemSpawnTimer += deltaTime;
            if (itemSpawnTimer >= ITEM_SPAWN_INTERVAL_BASE) {
                spawnNewItem();
                itemSpawnTimer = 0;
            }

            if (!gameOver) { 
                if (alivePlayers.length > 0) {
                    const firstPlayerBaseName = alivePlayers[0].baseName;
                    const allSameBaseName = alivePlayers.every(p => p.baseName === firstPlayerBaseName);
                    const initialPlayerBaseNames = new Set(allPlayers.map(p => p.baseName));
                    if (allSameBaseName && initialPlayerBaseNames.size > 1 && alivePlayers.length < allPlayers.length) { 
                        gameOver = true;
                        declareWinner(alivePlayers[0]); 
                    }
                }

                if (alivePlayers.length <= 1 && allPlayers.length > 1 && !gameOver) { 
                    gameOver = true; 
                    if (alivePlayers.length === 1) {
                        declareWinner(alivePlayers[0]);
                    } else { 
                        logBattleMessage('모든 참가자가 동시에 탈락했습니다! 아쉬운 무승부입니다.', 'log-event');
                        // resetGameComponents()는 declareWinner 또는 resetGame에서 처리
                        displayGameStats(); 
                    }
                }
            }


            if (!gameOver) { gameLoopId = requestAnimationFrame(gameLoop); }
        }
        
        function updateBattleStatsLog(alivePlayers) {
            if (gameOver || alivePlayers.length <= 1) return;
            let message = `현재 ${alivePlayers.length}명의 용사가 생존하여 치열한 전투를 벌이고 있습니다.`;
            const killLeaders = alivePlayers.filter(p => p.kills > 0).sort((a, b) => b.kills - a.kills);
            if (killLeaders.length > 0 && killLeaders[0].kills > 0) {
                 message += ` 현재 ${killLeaders[0].name} 선수가 ${killLeaders[0].kills}킬로 선두를 질주합니다!`;
            }
            logBattleMessage(message, 'log-stats');
        }


        function declareWinner(winner) {
            if (winnerSectionEl.style.display === 'block' && gameOver) return; 
            gameOver = true; cancelAnimationFrame(gameLoopId); 
            
            const winnerDisplayName = winner.baseName; 
            logBattleMessage(`👑 ${winnerDisplayName} 선수가 최후의 1인으로 등극했습니다! 대단합니다! 👑`, 'log-event');
            winnerNameEl.textContent = winnerDisplayName;
            winnerSectionEl.style.display = 'block';
            
            // resetGameComponents() 호출을 여기서 제거하고, resetGame()에서만 호출하도록 합니다.
            // 게임 종료 시 필요한 UI 상태 유지를 위함.
            speedControlsEl.style.display = 'none'; 
            gameCanvasEl.style.transform = ''; 
            isClutchCamActive = false;
            startButtonEl.disabled = true; // 게임 종료 후 시작 버튼 비활성화 유지
            participantsInputEl.disabled = true; // 게임 종료 후 입력창 비활성화 유지

            displayGameStats(); 
        }

        function displayGameStats() {
            gameStatsDisplayEl.innerHTML = '<h4>📊 게임 통계 📊</h4>';
            let maxKills = -1; 
            let mvpByKills = '-';
            allPlayers.forEach(p => {
                if (p.kills > maxKills) {
                    maxKills = p.kills;
                    mvpByKills = p.name;
                }
            });
            gameStatsDisplayEl.innerHTML += `<p>최다 킬: ${mvpByKills} (${maxKills}킬)</p>`;

            let maxDamage = 0;
            let mvpByDamage = '-';
            allPlayers.forEach(p => {
                if (p.damageDealt > maxDamage) {
                    maxDamage = p.damageDealt;
                    mvpByDamage = p.name;
                }
            });
            gameStatsDisplayEl.innerHTML += `<p>최고 데미지: ${mvpByDamage} (${maxDamage.toFixed(0)} 데미지)</p>`;
            
            let maxItemsUsed = -1;
            let mvpByItems = '-';
            allPlayers.forEach(p => {
                if (p.itemsUsed > maxItemsUsed) {
                    maxItemsUsed = p.itemsUsed;
                    mvpByItems = p.name;
                }
            });
            gameStatsDisplayEl.innerHTML += `<p>최다 아이템 사용: ${mvpByItems} (${maxItemsUsed}개)</p>`;

            let maxUltimatesUsed = -1;
            let mvpByUltimates = '-';
             allPlayers.forEach(p => {
                if (p.ultimatesUsed > maxUltimatesUsed) {
                    maxUltimatesUsed = p.ultimatesUsed;
                    mvpByUltimates = p.name;
                }
            });
            gameStatsDisplayEl.innerHTML += `<p>최다 필살기 사용: ${mvpByUltimates} (${maxUltimatesUsed}회)</p>`;
        }
        
        function resetGameComponents() { // 게임 UI를 초기 상태로 되돌리는 함수
            startButtonEl.disabled = false;
            participantsInputEl.disabled = false;
            speedControlsEl.style.display = 'none'; 
            gameCanvasEl.style.transform = ''; 
            isClutchCamActive = false;
            startScreenEl.style.display = 'flex'; 
            gameContainerEl.style.display = 'none'; 
            winnerSectionEl.style.display = 'none'; // 우승자 섹션도 숨김
            arenaSectionEl.style.display = 'none'; // 아레나 섹션 숨김
        }

        function logBattleMessage(message, type = '') { 
            const p = document.createElement('p');
            p.textContent = message;
            if (type) p.classList.add(type);
            battleLogEl.appendChild(p);
            if (battleLogEl.childNodes.length > 50) {
                battleLogEl.removeChild(battleLogEl.firstChild);
            }
            battleLogEl.scrollTop = battleLogEl.scrollHeight; 
        }

        function resetGame() { // 게임 전체를 리셋하고 시작 화면으로 돌아가는 함수
            gameOver = true; cancelAnimationFrame(gameLoopId); 
            allPlayers = []; items = []; obstacles = []; particles = []; attackEffects = [];
            grid = []; battleStatsLogInterval = 0; itemSpawnTimer = 0; gameStartTime = 0;
            baseNameColors = {}; colorIndex = 0; // 색상 맵 초기화
            selectedMapType = 'default'; // 맵 선택 초기화
            gameSpeedMultiplier = 1; // 게임 속도 초기화
            setActiveSpeedButton(1); // 배속 버튼 UI 초기화

            if (ctx) { // ctx가 유효할 때만 clearRect 호출
                 ctx.clearRect(0, 0, gameCanvasEl.width, gameCanvasEl.height);
            }
            participantsDisplayEl.innerHTML = ''; battleLogEl.innerHTML = '';
            winnerNameEl.textContent = ''; 
            gameStatsDisplayEl.innerHTML = ''; 
            participantsInputEl.value = ''; 
            resetGameComponents(); // UI를 시작 화면 상태로
        }
        
        function alertUser(message) {
            const existingModal = document.getElementById('customAlertModal');
            if (existingModal) existingModal.remove();
            const modal = document.createElement('div');
            modal.id = 'customAlertModal';
            modal.innerHTML = `<p>${message}</p><button id="customAlertOk">확인</button>`;
            document.body.appendChild(modal);
            document.getElementById('customAlertOk').addEventListener('click', () => modal.remove());
        }

        // 배속 버튼 이벤트 리스너
        function setActiveSpeedButton(speed) {
            [speed1xButton, speed2xButton, speed4xButton].forEach(btn => btn.classList.remove('active'));
            if (speed === 1) speed1xButton.classList.add('active');
            else if (speed === 2) speed2xButton.classList.add('active');
            else if (speed === 4) speed4xButton.classList.add('active');
        }
        speed1xButton.addEventListener('click', () => { gameSpeedMultiplier = 1; setActiveSpeedButton(1); });
        speed2xButton.addEventListener('click', () => { gameSpeedMultiplier = 2; setActiveSpeedButton(2); });
        speed4xButton.addEventListener('click', () => { gameSpeedMultiplier = 4; setActiveSpeedButton(4); });


        // 이벤트 리스너
        startButtonEl.addEventListener('click', setupBattle);
        resetButtonEl.addEventListener('click', resetGame);
        
        window.addEventListener('resize', () => {
            if (arenaSectionEl.style.display === 'block' && gameCanvasEl.offsetParent !== null) { 
                const oldWidth = gameCanvasEl.width;
                const oldHeight = gameCanvasEl.height;
                gameCanvasEl.width = gameCanvasEl.offsetWidth;
                gameCanvasEl.height = gameCanvasEl.offsetHeight;
                if (oldWidth > 0 && oldHeight > 0 && allPlayers.length > 0) { 
                    const scaleX = gameCanvasEl.width / oldWidth;
                    const scaleY = gameCanvasEl.height / oldHeight;
                    const newGridCols = Math.floor(gameCanvasEl.width / GRID_CELL_SIZE);
                    const newGridRows = Math.floor(gameCanvasEl.height / GRID_CELL_SIZE);
                    if (newGridRows > 0 && newGridCols > 0) {
                        grid = Array(newGridRows).fill(null).map(() => Array(newGridCols).fill(0));
                        obstacles.forEach(o => { 
                            o.x *= scaleX; o.y *= scaleY; o.width *= scaleX; o.height *= scaleY;
                            if (o.isRound) o.radius *= Math.min(scaleX, scaleY); 
                            o.x = Math.max(0, Math.min(o.x, gameCanvasEl.width - o.width));
                            o.y = Math.max(0, Math.min(o.y, gameCanvasEl.height - o.height));
                            const startCol = Math.max(0, Math.floor(o.x / GRID_CELL_SIZE));
                            const endCol = Math.min(newGridCols - 1, Math.floor((o.x + o.width) / GRID_CELL_SIZE));
                            const startRow = Math.max(0, Math.floor(o.y / GRID_CELL_SIZE));
                            const endRow = Math.min(newGridRows - 1, Math.floor((o.y + o.height) / GRID_CELL_SIZE));
                            for (let r = startRow; r <= endRow; r++) {
                                for (let c = startCol; c <= endCol; c++) {
                                    if (grid[r] && grid[r][c] !== undefined && o.type === 'wall') grid[r][c] = 1; 
                                }
                            }
                        });
                    } else { grid = [[0]]; }
                    items.forEach(i => {
                        i.x *= scaleX; i.y *= scaleY;
                        i.x = Math.max(i.radius, Math.min(i.x, gameCanvasEl.width - i.radius));
                        i.y = Math.max(i.radius, Math.min(i.y, gameCanvasEl.height - i.radius));
                    });
                     allPlayers.forEach(p => {
                        p.x *= scaleX; p.y *= scaleY;
                        p.x = Math.max(p.radius, Math.min(p.x, gameCanvasEl.width - p.radius));
                        p.y = Math.max(p.radius, Math.min(p.y, gameCanvasEl.height - p.radius));
                        p.path = []; 
                    });
                } else if (allPlayers.length === 0) { initGameArena(); }
                if (!gameOver) { 
                    ctx.clearRect(0, 0, gameCanvasEl.width, gameCanvasEl.height);
                    items.forEach(i => i.draw()); obstacles.forEach(o => o.draw()); 
                    allPlayers.filter(p => p.isAlive).forEach(player => player.draw());
                } else if (winnerSectionEl.style.display === 'block') { 
                    ctx.clearRect(0, 0, gameCanvasEl.width, gameCanvasEl.height);
                    obstacles.forEach(o => o.draw());
                }
            }
        });
    </script>
</body>
</html>
